<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Visual Appointment Timer">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#61dafb">
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-TileColor" content="#61dafb">
    <meta name="msapplication-tap-highlight" content="no">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    
    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" href="./vta-192.png">
    <link rel="apple-touch-icon" sizes="192x192" href="./vta-192.png">
    <link rel="apple-touch-icon" sizes="512x512" href="./vta-512.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="192x192" href="./vta-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="./vta-512.png">
    <link rel="shortcut icon" href="./vta-192.png">
    
    <title>Visual Appointment Timer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #61dafb;
            --primary-gradient: linear-gradient(135deg, #61dafb 0%, #21CBF3 50%, #2196F3 100%);
            --secondary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --accent-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --success-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --background-color: #0a0e1a;
            --background-gradient: radial-gradient(ellipse at top, #1a1a2e 0%, #16213e 50%, #0f1419 100%);
            --card-background: rgba(30, 35, 50, 0.95);
            --glass-background: rgba(25, 30, 45, 0.85);
            --glass-light: rgba(255, 255, 255, 0.05);
            --glass-medium: rgba(255, 255, 255, 0.1);
            --text-color: #ffffff;
            --light-text-color: #cbd5e0;
            --muted-text-color: #a0aec0;
            --help-text-color: #8892b0;
            --hours-color: #667eea;
            --minutes-color: #f093fb;
            --seconds-color: #4facfe;
            --warning-color: #ffa726;
            --warning-gradient: linear-gradient(135deg, #ffa726 0%, #fb8c00 100%);
            --alarm-color: #ef5350;
            --alarm-gradient: linear-gradient(135deg, #ef5350 0%, #e53935 100%);
            --danger-gradient: linear-gradient(135deg, #ef5350 0%, #e53935 100%);
            --success-color: #66bb6a;
            --input-background: rgba(45, 55, 75, 0.9);
            --input-border: rgba(255, 255, 255, 0.1);
            --input-border-focus: rgba(97, 218, 251, 0.5);
            --border-radius: 16px;
            --border-radius-lg: 20px;
            --border-radius-xl: 24px;
            --transition-duration: 0.3s;
            --transition-fast: 0.15s;
            --shadow-sm: 0 2px 10px rgba(0, 0, 0, 0.1);
            --shadow-md: 0 4px 20px rgba(0, 0, 0, 0.15);
            --shadow-lg: 0 8px 30px rgba(0, 0, 0, 0.2);
            --shadow-xl: 0 12px 40px rgba(0, 0, 0, 0.25);
            --shadow-2xl: 0 20px 60px rgba(0, 0, 0, 0.3);
            --glow-primary: 0 0 30px rgba(97, 218, 251, 0.3);
            --glow-secondary: 0 0 20px rgba(102, 126, 234, 0.2);
            --blur: blur(20px);
            --blur-heavy: blur(40px);
        }

        html, body {
            height: 100%;
            font-family: 'Roboto', sans-serif;
        }

        body {
            background: var(--background-color);
            min-height: 100vh;
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            background: var(--background-gradient);
            padding: env(safe-area-inset-top) 20px env(safe-area-inset-bottom) 20px;
            position: relative;
            overflow-x: hidden;
            touch-action: manipulation;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes glow {
            0%, 100% { box-shadow: var(--shadow-xl), var(--glow-primary); }
            50% { box-shadow: var(--shadow-2xl), var(--glow-secondary); }
        }

        @keyframes shimmer {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 80%, rgba(97, 218, 251, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(102, 126, 234, 0.08) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(168, 85, 247, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 60% 80%, rgba(240, 147, 251, 0.06) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
            animation: glow 4s ease-in-out infinite;
        }

        .app-container {
            width: 100%;
            max-width: 650px;
            margin: 0 auto;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .main-container {
            background: var(--glass-background);
            border-radius: var(--border-radius-xl);
            box-shadow: var(--shadow-2xl), inset 0 1px 0 var(--glass-light);
            padding: 40px;
            margin-bottom: 30px;
            backdrop-filter: var(--blur);
            border: 1px solid rgba(97, 218, 251, 0.15);
            position: relative;
            overflow: hidden;
            transition: all var(--transition-duration) ease;
        }

        .main-container:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-2xl), var(--glow-primary), inset 0 1px 0 var(--glass-medium);
            border-color: rgba(97, 218, 251, 0.25);
        }

        .main-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary-gradient);
            border-radius: var(--border-radius-xl) var(--border-radius-xl) 0 0;
        }

        .main-container::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: conic-gradient(from 0deg, transparent, rgba(97, 218, 251, 0.05), transparent);
            animation: rotate 20s linear infinite;
            pointer-events: none;
            z-index: -1;
        }

        @keyframes rotate {
            to { transform: rotate(360deg); }
        }

        .app-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            text-align: center;
        }

        .app-icon {
            width: 80px;
            height: 80px;
            border-radius: 20px;
            box-shadow: var(--shadow-lg);
            flex-shrink: 0;
            background: var(--primary-gradient);
            border: 2px solid rgba(97, 218, 251, 0.3);
        }

        .app-title {
            font-size: 2.5em;
            font-weight: 700;
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: 0.5px;
            margin: 0;
            line-height: 1.2;
        }

        #currentTime {
            font-size: 1.3em;
            font-weight: 500;
            text-align: center;
            margin: 30px 0;
            color: var(--light-text-color);
            letter-spacing: 1px;
            padding: 16px 24px;
            background: rgba(97, 218, 251, 0.05);
            border-radius: var(--border-radius);
            border: 1px solid rgba(97, 218, 251, 0.1);
        }

        .form-section {
            background: var(--card-background);
            border-radius: var(--border-radius-xl);
            padding: 35px;
            margin-bottom: 30px;
            box-shadow: var(--shadow-lg), inset 0 1px 0 var(--glass-light);
            border: 1px solid var(--glass-light);
            position: relative;
            overflow: hidden;
        }

        .form-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(97, 218, 251, 0.4), transparent);
        }

        .form-section.editing {
            border: 2px solid #f59e0b;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.08), rgba(245, 158, 11, 0.03));
            box-shadow: var(--shadow-xl), 0 0 25px rgba(245, 158, 11, 0.2), inset 0 1px 0 var(--glass-medium);
        }

        .form-section.editing::before {
            background: linear-gradient(90deg, transparent, rgba(245, 158, 11, 0.6), transparent);
            height: 2px;
        }

        .form-section.editing::after {
            content: "✏️ EDITING APPOINTMENT";
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #f59e0b, #f97316);
            color: white;
            padding: 6px 16px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
            z-index: 10;
        }

        .form-row {
            margin-bottom: 25px;
            position: relative;
        }

        label {
            display: block;
            color: var(--light-text-color);
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 0.95em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            position: relative;
        }

        label::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 0;
            height: 2px;
            background: var(--primary-gradient);
            transition: width var(--transition-duration) ease;
        }

        .form-row:focus-within label::after {
            width: 100%;
        }

        .field-help {
            display: block;
            color: var(--help-text-color);
            font-size: 0.85em;
            margin-top: 6px;
            font-style: italic;
            opacity: 0.8;
            transition: opacity var(--transition-duration) ease;
        }

        .input-feedback {
            font-size: 0.8em;
            margin-top: 4px;
            min-height: 16px;
            transition: all var(--transition-duration) ease;
        }

        .input-feedback.success {
            color: var(--success-color);
        }

        .input-feedback.error {
            color: var(--alarm-color);
        }

        .form-row:focus-within .field-help {
            opacity: 1;
        }

        input, select {
            width: 100%;
            padding: 18px 24px;
            border: 2px solid var(--input-border);
            border-radius: var(--border-radius);
            font-size: 1.1em;
            background: var(--input-background);
            color: var(--text-color);
            transition: all var(--transition-duration) ease;
            position: relative;
            backdrop-filter: blur(10px);
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: textfield;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary-color);
            background: rgba(45, 55, 75, 1);
            box-shadow: var(--shadow-md), 0 0 0 4px rgba(97, 218, 251, 0.1);
        }

        input:hover, select:hover {
            border-color: rgba(97, 218, 251, 0.3);
        }

        /* Enhanced input styling for better UX */
        input[type="time"] {
            font-family: 'Roboto', monospace;
            letter-spacing: 1px;
            cursor: pointer;
        }

        input[type="text"] {
            text-transform: uppercase;
            text-align: center;
            font-weight: 600;
            letter-spacing: 2px;
        }

        select {
            cursor: pointer;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%2361dafb' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 12px center;
            background-repeat: no-repeat;
            background-size: 16px;
            padding-right: 48px;
        }

        .reminder-section {
            margin-bottom: 20px;
        }

        .reminder-section > label {
            display: block;
            margin-bottom: 15px;
            font-weight: 600;
            color: #fff;
            font-size: 16px;
        }

        .selected-count {
            font-size: 14px;
            opacity: 0.8;
            font-weight: normal;
            margin-left: 10px;
            color: var(--primary-color);
        }

        .reminder-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            gap: 8px;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
            padding: 5px;
        }

        /* Custom scrollbar for reminder grid */
        .reminder-grid::-webkit-scrollbar {
            width: 6px;
        }

        .reminder-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .reminder-grid::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #61dafb 0%, #3498db 100%);
            border-radius: 3px;
        }

        .reminder-grid::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }

        /* Firefox scrollbar for reminder grid */
        .reminder-grid {
            scrollbar-width: thin;
            scrollbar-color: #61dafb rgba(255, 255, 255, 0.05);
        }

        .reminder-item {
            position: relative;
        }

        .reminder-item input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        .reminder-item label {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: all var(--transition-duration) ease;
            margin: 0;
            text-transform: none;
            font-size: 0.95em;
            text-align: center;
            min-height: 44px;
            position: relative;
        }

        .reminder-item label:hover {
            background: rgba(97, 218, 251, 0.1);
            border-color: rgba(97, 218, 251, 0.2);
        }

        .reminder-item input[type="checkbox"]:checked + label {
            background: rgba(97, 218, 251, 0.2);
            border-color: var(--primary-color);
            color: var(--primary-color);
            box-shadow: 0 0 10px rgba(97, 218, 251, 0.3);
        }

        .checkmark {
            opacity: 0;
            transition: opacity 0.15s ease-in-out;
            background: rgba(34, 197, 94, 0.9);
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            position: absolute;
            top: 2px;
            right: 2px;
            z-index: 15;
            border: none;
            outline: none;
            font-family: inherit;
            pointer-events: none;
        }

        .reminder-item input[type="checkbox"]:checked + label .checkmark {
            opacity: 1;
            background: rgba(34, 197, 94, 1);
        }

        .warning-section {
            margin-bottom: 20px;
        }

        .warning-section label {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: rgba(255, 193, 7, 0.08);
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 193, 7, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0;
        }

        .warning-section label:hover {
            background: rgba(255, 193, 7, 0.12);
            border-color: rgba(255, 193, 7, 0.3);
        }

        .three-minute-checkbox {
            appearance: none;
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 193, 7, 0.5);
            border-radius: 4px;
            background: transparent;
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            margin: 0;
        }

        .three-minute-checkbox:checked {
            background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);
            border-color: #ffc107;
        }

        .three-minute-checkbox:checked::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        .checkbox-label {
            font-weight: 500;
            color: var(--text-color);
            user-select: none;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .volume-section {
            margin-bottom: 20px;
        }

        .volume-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.02);
            border-radius: var(--border-radius);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .volume-controls label {
            min-width: 70px;
            margin: 0;
            text-transform: none;
        }

        .volume-slider {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: var(--input-background);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            border: none;
            margin: 0;
            padding: 0;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-gradient);
            cursor: pointer;
            box-shadow: var(--shadow-md);
        }

        .volume-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary-gradient);
            cursor: pointer;
            border: none;
            box-shadow: var(--shadow-md);
        }

        #volumeValue {
            min-width: 45px;
            text-align: right;
            color: var(--primary-color);
            font-weight: 600;
        }

        .add-button {
            width: 100%;
            padding: 18px 20px;
            background: var(--primary-gradient);
            color: #ffffff;
            border: none;
            border-radius: var(--border-radius);
            font-size: 1.1em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            box-shadow: var(--shadow-md);
            position: relative;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5), 0 0 12px rgba(0, 0, 0, 0.3);
        }

        .add-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.6s ease;
        }

        .add-button:hover::before {
            left: 100%;
        }

        .add-button:hover {
            box-shadow: var(--shadow-lg), 0 10px 30px rgba(97, 218, 251, 0.3);
            background: var(--secondary-gradient);
        }

        .add-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .button-container {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
        }

        .cancel-button {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            padding: 14px 24px;
            border: none;
            border-radius: var(--border-radius-lg);
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: all var(--transition-duration) ease;
            position: relative;
            overflow: hidden;
        }

        .cancel-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.6s ease;
        }

        .cancel-button:hover::before {
            left: 100%;
        }

        .cancel-button:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            box-shadow: var(--shadow-lg), 0 10px 30px rgba(239, 68, 68, 0.3);
        }

        .appointments-section {
            margin-top: 30px;
        }

        .appointments-section h2 {
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 24px;
            font-weight: 700;
            font-size: 1.6em;
        }

        .appointment {
            background: var(--card-background);
            padding: 30px 25px;
            margin-bottom: 25px;
            border-radius: var(--border-radius-xl);
            box-shadow: var(--shadow-lg), inset 0 1px 0 var(--glass-light);
            border: 1px solid var(--glass-light);
            position: relative;
            transition: all var(--transition-duration) ease;
        }

        .appointment:hover {
            box-shadow: var(--shadow-2xl), var(--glow-primary), inset 0 1px 0 var(--glass-medium);
        }

        .appointment.editing {
            border: 2px solid #f59e0b;
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(245, 158, 11, 0.05));
            box-shadow: var(--shadow-xl), 0 0 20px rgba(245, 158, 11, 0.3), inset 0 1px 0 var(--glass-medium);
            transform: translateY(-2px);
        }

        .appointment.editing::before {
            content: "✏️ EDITING";
            position: absolute;
            top: -12px;
            right: 20px;
            background: linear-gradient(135deg, #f59e0b, #f97316);
            color: white;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.5px;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.4);
            z-index: 10;
        }

        .appointment.editing .appointment-info {
            border-bottom: 2px dashed rgba(245, 158, 11, 0.3);
            padding-bottom: 15px;
            margin-bottom: 20px;
        }

        .appointment-info {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 25px;
        }

        .appointment-details {
            flex: 1;
        }

        .appointment-title {
            font-size: 1.2em;
            font-weight: 700;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .appointment-timing {
            background: rgba(97, 218, 251, 0.05);
            border: 1px solid rgba(97, 218, 251, 0.1);
            border-radius: var(--border-radius);
            padding: 12px 16px;
            margin: 12px 0;
            font-size: 0.9em;
        }

        .timing-row {
            display: grid;
            grid-template-columns: 140px 1fr;
            gap: 12px;
            align-items: center;
            margin-bottom: 8px;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .timing-row:last-child {
            margin-bottom: 0;
            border-bottom: none;
        }

        .timing-label {
            color: var(--light-text-color);
            font-weight: 500;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
            white-space: nowrap;
            justify-self: start;
        }

        .timing-value {
            color: var(--primary-color);
            font-weight: 600;
            font-family: 'Roboto', monospace;
            font-size: 14px;
            text-align: left;
            justify-self: start;
            line-height: 1.4;
            word-break: break-word;
        }

        /* Special styling for reminder row to handle long lists */
        .timing-row.reminder-row .timing-value {
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            max-width: 100%;
        }

        /* Compact layout for very long reminder lists */
        .timing-row.compact .timing-value {
            font-size: 12px;
            line-height: 1.2;
        }

        .alarm-indicator {
            background: var(--warning-gradient);
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
            animation: pulse 2s ease-in-out infinite;
        }

        .countdown-container {
            display: flex;
            height: 60px;
            background: rgba(15, 20, 35, 0.9);
            border-radius: var(--border-radius);
            overflow: hidden;
            margin-bottom: 20px;
            border: 1px solid var(--glass-light);
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.4);
            position: relative;
        }

        .countdown-segment {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ffffff;
            font-weight: 700;
            letter-spacing: 0.5px;
            position: relative;
            transition: all 0.5s ease-out;
            flex: 1;
            min-width: 0;
        }

        .countdown-number {
            font-size: 1.3em;
            line-height: 1;
            margin-bottom: 2px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.6), 0 0 8px rgba(0, 0, 0, 0.4);
        }

        .countdown-label {
            font-size: 0.7em;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
            white-space: nowrap;
            overflow: hidden;
            transition: all 0.3s ease;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5), 0 0 6px rgba(0, 0, 0, 0.3);
        }

        /* Responsive countdown labels based on segment width */
        .countdown-segment {
            position: relative;
        }

        .countdown-segment[data-width="narrow"] .countdown-label {
            font-size: 0.6em;
            letter-spacing: 0.5px;
        }

        .countdown-segment[data-width="very-narrow"] .countdown-label {
            font-size: 0.55em;
            letter-spacing: 0px;
        }

        /* Hide labels entirely on very small segments */
        .countdown-segment[data-width="tiny"] .countdown-label {
            display: none;
        }

        .countdown-segment::after {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 1px;
            height: 100%;
            background: rgba(255, 255, 255, 0.15);
        }

        .countdown-segment:last-child::after {
            display: none;
        }

        .hours { 
            background: linear-gradient(135deg, var(--hours-color) 0%, #4c6ef5 100%);
        }
        .minutes { 
            background: linear-gradient(135deg, var(--minutes-color) 0%, #f06292 100%);
        }
        .seconds { 
            background: linear-gradient(135deg, var(--seconds-color) 0%, #00d4aa 100%);
        }

        .countdown-text {
            text-align: center;
            font-size: 2.2em;
            font-weight: 800;
            margin: 20px 0;
            color: var(--text-color);
            letter-spacing: 3px;
            font-family: 'Roboto', monospace;
            background: linear-gradient(135deg, #ffffff 0%, var(--primary-color) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 4px 20px rgba(97, 218, 251, 0.3);
            transition: all 0.3s ease;
        }

        .countdown-text.urgent {
            animation: urgentPulse 1s ease-in-out infinite;
            font-size: 2.4em;
        }

        @keyframes urgentPulse {
            0%, 100% { 
                transform: scale(1);
                text-shadow: 0 4px 20px rgba(239, 83, 80, 0.5);
            }
            50% { 
                transform: scale(1.05);
                text-shadow: 0 6px 30px rgba(239, 83, 80, 0.8);
            }
        }

        .countdown-text.warning {
            background: linear-gradient(135deg, #ffa726 0%, #ff9800 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .reminder-indicator {
            height: 10px;
            background: rgba(97, 218, 251, 0.2);
            margin: 20px 0;
            width: 100%;
            border-radius: 5px;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
            --progress: 0%;
            --indicator-color: var(--primary-gradient);
        }

        .reminder-indicator::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            width: var(--progress);
            background: var(--indicator-color);
            border-radius: 5px;
            transition: width 1s ease-out, background 1s ease;
            box-shadow: 0 0 10px rgba(255, 167, 38, 0.4);
        }

        .reminder-indicator::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
            animation: shimmer 2s infinite;
        }

        .info-container {
            background: var(--card-background);
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--shadow-md);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .info-container p {
            color: var(--light-text-color);
            text-align: center;
            margin: 0;
            line-height: 1.6;
        }

        /* Responsive Design */
        @media (max-width: 700px) {
            .main-container {
                padding: 20px;
                margin-bottom: 20px;
            }
            
            .form-section {
                padding: 20px;
            }
            
            .app-title {
                font-size: 1.8em;
            }
            
            .app-icon {
                width: 60px;
                height: 60px;
            }
            
            .reminder-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }
            
            .appointment {
                padding: 16px;
            }
            
            .appointment-info {
                flex-direction: column;
                align-items: stretch;
                gap: 12px;
            }
            
            .appointment-buttons {
                justify-content: center;
            }
        }

        @media (max-width: 480px) {
            .main-container {
                padding: 16px;
            }
            
            .app-header {
                flex-direction: column;
                gap: 12px;
            }
            
            .app-title {
                font-size: 1.5em;
            }
            
            .reminder-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .timing-row {
                grid-template-columns: 120px 1fr;
                gap: 8px;
                margin-bottom: 10px;
                padding: 8px 0;
            }
            
            .timing-label {
                font-size: 13px;
            }
            
            .timing-value {
                font-size: 13px;
                line-height: 1.3;
            }
        }
        /* Appointment Button Styles */
        .appointment-buttons {
            display: flex;
            gap: 12px;
            flex-shrink: 0;
            margin-left: 15px;
        }

        .appointment button {
            min-height: 48px;
            min-width: 48px;
            padding: 12px 18px;
            font-size: 0.9em;
            border-radius: var(--border-radius);
            border: none;
            cursor: pointer;
            font-weight: 600;
            transition: all var(--transition-duration) ease;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
            text-shadow: 0 2px 3px rgba(0, 0, 0, 0.5), 0 0 8px rgba(0, 0, 0, 0.3);
        }

        .appointment button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .appointment button:hover::before {
            left: 100%;
        }

        .edit-btn {
            background: var(--success-gradient);
            color: #fff;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }

        .edit-btn:hover {
            background: linear-gradient(135deg, #388E3C 0%, #4CAF50 100%);
            box-shadow: var(--shadow-lg), 0 8px 25px rgba(76, 175, 80, 0.3);
        }

        .remove-btn {
            background: var(--danger-gradient);
            color: #fff;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }

        .remove-btn:hover {
            background: linear-gradient(135deg, #c0392b 0%, #e74c3c 100%);
            box-shadow: var(--shadow-lg), 0 8px 25px rgba(244, 67, 54, 0.3);
        }

        .type-indicator {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            color: white;
            font-weight: 700;
            font-size: 0.8em;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2), inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .past {
            opacity: 0.7;
            filter: grayscale(20%);
        }

        .past .appointment-title {
            text-decoration: line-through;
        }

        @media (max-width: 768px) {
            .appointment-info {
                flex-direction: column;
                gap: 15px;
            }

            .appointment-buttons {
                margin-left: 0;
                justify-content: flex-end;
            }

            .appointment button {
                min-width: 44px;
                padding: 10px 14px;
                font-size: 0.8em;
            }
        }

        /* PWA Enhancement Styles */

        .update-button {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--warning-gradient);
            color: white;
            border: none;
            border-radius: var(--border-radius);
            padding: 12px 20px;
            font-weight: 600;
            cursor: pointer;
            z-index: 9999;
            box-shadow: var(--shadow-lg);
            animation: slideDown 0.3s ease-out;
            text-shadow: 0 2px 3px rgba(0, 0, 0, 0.5), 0 0 8px rgba(0, 0, 0, 0.3);
        }

        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }

        /* Enhanced mobile support and accessibility */
        @media (display-mode: standalone) {
            body {
                padding-top: env(safe-area-inset-top);
                padding-bottom: env(safe-area-inset-bottom);
            }
            
            .main-container {
                margin-top: 10px;
            }
        }

        /* Dark mode enhancements for PWA */
        @media (prefers-color-scheme: dark) {
            :root {
                --background-color: #000000;
                --card-background: rgba(20, 25, 40, 0.95);
            }
        }

        /* Enhanced accessibility */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
                scroll-behavior: auto !important;
            }
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            :root {
                --primary-color: #00ff00;
                --text-color: #ffffff;
                --background-color: #000000;
            }
        }

        /* Focus indicators for accessibility */
        .appointment button:focus-visible,
        .add-button:focus-visible,
        .reminder-item input:focus-visible + label,
        input:focus-visible,
        select:focus-visible {
            outline: 3px solid var(--primary-color);
            outline-offset: 2px;
        }

        /* Loading states */
        .loading {
            opacity: 0.7;
            pointer-events: none;
            cursor: wait;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid var(--primary-color);
            border-top: 2px solid transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Enhanced error states */
        .error {
            border-color: var(--alarm-color) !important;
            box-shadow: 0 0 0 3px rgba(239, 83, 80, 0.2) !important;
        }

        .success {
            border-color: var(--success-color) !important;
            box-shadow: 0 0 0 3px rgba(102, 187, 106, 0.2) !important;
        }

    /* Haptic feedback visual animation removed to prevent layout jump */

        /* Attention-grabbing animations for countdown phase */
        @keyframes gentleShake {
            0%, 100% { transform: translateX(0) translateY(0); }
            10% { transform: translateX(-2px) translateY(-1px); }
            20% { transform: translateX(2px) translateY(1px); }
            30% { transform: translateX(-1px) translateY(-2px); }
            40% { transform: translateX(1px) translateY(2px); }
            50% { transform: translateX(-2px) translateY(1px); }
            60% { transform: translateX(2px) translateY(-1px); }
            70% { transform: translateX(-1px) translateY(2px); }
            80% { transform: translateX(1px) translateY(-2px); }
            90% { transform: translateX(-2px) translateY(-1px); }
        }

        @keyframes focusGlow {
            0%, 100% { 
                box-shadow: var(--shadow-lg), inset 0 1px 0 var(--glass-light);
                border-color: var(--glass-light);
            }
            50% { 
                box-shadow: var(--shadow-2xl), var(--glow-primary), inset 0 1px 0 var(--glass-medium);
                border-color: rgba(97, 218, 251, 0.4);
            }
        }

        @keyframes pulseAttention {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Appointment attention states */
        .appointment.in-countdown {
            animation: focusGlow 3s ease-in-out infinite;
            position: relative;
            z-index: 10;
            background: radial-gradient(ellipse at center, rgba(255, 193, 7, 0.15) 0%, rgba(255, 152, 0, 0.1) 40%, transparent 80%);
            border: 1px solid rgba(255, 193, 7, 0.3);
        }

        .appointment.in-countdown::before {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            background: radial-gradient(ellipse at center, rgba(255, 193, 7, 0.2) 0%, rgba(255, 152, 0, 0.1) 50%, transparent 80%);
            border-radius: var(--border-radius-xl);
            z-index: -1;
            animation: countdownGlow 2s ease-in-out infinite;
        }

        @keyframes countdownGlow {
            0%, 100% { 
                opacity: 0.6;
                transform: scale(1);
            }
            50% { 
                opacity: 1;
                transform: scale(1.02);
            }
        }

        .appointment.shake-attention {
            animation: gentleShake 0.6s ease-in-out;
        }

        .appointment.urgent-attention {
            animation: gentleShake 0.6s ease-in-out, pulseAttention 2s ease-in-out infinite;
        }

        .appointment.warning-attention {
            animation: focusGlow 2s ease-in-out infinite, pulseAttention 3s ease-in-out infinite;
        }

        /* Modern Floating Timer Hub - Minimalist Design */
        .timer-hub-container {
            position: fixed;
            top: max(20px, env(safe-area-inset-top, 20px));
            right: 20px;
            z-index: 9999;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            pointer-events: none;
            will-change: transform;
        }

        .timer-hub-container * {
            pointer-events: auto;
        }

        /* Floating Action Button (FAB) */
        .timer-hub-fab {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: var(--primary-gradient);
            border: none;
            box-shadow: 0 6px 20px rgba(97, 218, 251, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: white;
            font-size: 24px;
            user-select: none;
            touch-action: manipulation;
            outline: none;
            will-change: transform, box-shadow;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5), 0 0 12px rgba(0, 0, 0, 0.3);
        }

        .timer-hub-fab::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border-radius: 50%;
            background: linear-gradient(45deg, var(--primary-color), var(--secondary-gradient));
            opacity: 0;
            z-index: -1;
            transition: opacity 0.3s ease;
        }

        .timer-hub-fab:hover::before {
            opacity: 0.2;
        }

        .timer-hub-fab:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 25px rgba(97, 218, 251, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.2);
        }

        .timer-hub-fab.has-timers {
            animation: fabPulse 2s ease-in-out infinite;
        }

        @keyframes fabPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 6px 20px rgba(97, 218, 251, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 8px 25px rgba(97, 218, 251, 0.6), 0 0 0 1px rgba(255, 255, 255, 0.2);
            }
        }

        /* Badge for timer count */
        .timer-hub-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            background: #ef5350;
            color: white;
            border-radius: 50%;
            min-width: 22px;
            height: 22px;
            font-size: 11px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: scale(0);
            transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 8px rgba(239, 83, 80, 0.4);
            border: 2px solid white;
            padding: 0 4px;
        }

        .timer-hub-badge.visible {
            transform: scale(1);
        }

        .timer-hub-badge.urgent {
            animation: badgeUrgent 1s ease-in-out infinite;
            background: #d32f2f;
        }

        @keyframes badgeUrgent {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 2px 8px rgba(239, 83, 80, 0.4);
            }
            50% { 
                transform: scale(1.15);
                box-shadow: 0 4px 12px rgba(239, 83, 80, 0.6);
            }
        }

        /* Expandable Timer Panel */
        .timer-hub-panel {
            position: absolute;
            top: 70px;
            right: 0;
            width: 320px;
            max-width: calc(100vw - 80px);
            max-height: calc(100vh - 140px);
            background: var(--glass-background);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 16px;
            border: 1px solid var(--glass-light);
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-20px) scale(0.9);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform-origin: top right;
            overflow: hidden;
            will-change: transform, opacity;
        }

        .timer-hub-panel.expanded {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }

        .timer-hub-panel-header {
            padding: 16px 20px 12px;
            border-bottom: 1px solid var(--glass-light);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.02);
        }

        .timer-hub-panel-title {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-color);
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0;
        }

        .timer-hub-panel-title::before {
            content: "⏲️";
            font-size: 18px;
        }

        .timer-hub-close {
            background: rgba(255, 255, 255, 0.05);
            border: none;
            color: var(--muted-text-color);
            cursor: pointer;
            padding: 6px;
            border-radius: 6px;
            transition: all 0.2s ease;
            font-size: 16px;
            line-height: 1;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-shadow: 0 2px 3px rgba(0, 0, 0, 0.4);
        }

        .timer-hub-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            transform: scale(1.1);
        }

        .timer-hub-list {
            max-height: calc(100vh - 220px);
            overflow-y: auto;
            padding: 8px 0;
            scrollbar-width: thin;
            scrollbar-color: rgba(97, 218, 251, 0.3) transparent;
        }

        .timer-hub-list::-webkit-scrollbar {
            width: 4px;
        }

        .timer-hub-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .timer-hub-list::-webkit-scrollbar-thumb {
            background: rgba(97, 218, 251, 0.3);
            border-radius: 2px;
        }

        .timer-hub-list::-webkit-scrollbar-thumb:hover {
            background: rgba(97, 218, 251, 0.5);
        }

        /* Individual Timer Items */
        .timer-hub-item {
            padding: 14px 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
            transition: all 0.2s ease;
            cursor: pointer;
            position: relative;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .timer-hub-item:hover {
            background: rgba(255, 255, 255, 0.05);
            transform: translateX(-2px);
        }

        .timer-hub-item:last-child {
            border-bottom: none;
        }

        .timer-hub-item-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
            position: relative;
            border: 2px solid currentColor;
            transition: all 0.2s ease;
        }

        .timer-hub-item-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: currentColor;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .timer-hub-item.urgent .timer-hub-item-indicator::after {
            opacity: 1;
            animation: indicatorPulse 1s ease-in-out infinite;
        }

        @keyframes indicatorPulse {
            0%, 100% { 
                opacity: 1; 
                transform: translate(-50%, -50%) scale(1);
            }
            50% { 
                opacity: 0.5; 
                transform: translate(-50%, -50%) scale(1.5);
            }
        }

        @keyframes highlightPulse {
            0% { box-shadow: 0 2px 8px rgba(97, 218, 251, 0.08); }
            50% { box-shadow: 0 4px 20px rgba(97, 218, 251, 0.4), 0 0 30px rgba(97, 218, 251, 0.3); }
            100% { box-shadow: 0 2px 8px rgba(97, 218, 251, 0.08); }
        }

        .timer-hub-item-content {
            flex: 1;
            min-width: 0;
        }

        .timer-hub-item-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-color);
            margin: 0 0 4px 0;
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .timer-hub-item-time {
            font-size: 20px;
            font-weight: 700;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Roboto Mono', monospace;
            letter-spacing: 0.5px;
            margin: 0;
            line-height: 1;
        }

        .timer-hub-item-status {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
            margin: 4px 0 0 0;
            opacity: 0.7;
        }

        /* Status-based styling */
        .timer-hub-item.countdown {
            color: var(--primary-color);
        }

        .timer-hub-item.warning {
            color: #ffa726;
        }

        .timer-hub-item.urgent {
            color: #ef5350;
        }

        /* Empty state */
        .timer-hub-empty {
            padding: 40px 20px;
            text-align: center;
            color: var(--muted-text-color);
        }

        .timer-hub-empty-icon {
            font-size: 48px;
            opacity: 0.3;
            margin-bottom: 12px;
        }

        .timer-hub-empty-text {
            font-size: 14px;
            margin: 0;
            opacity: 0.7;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .timer-hub-container {
                top: 16px;
                right: 16px;
            }

            .timer-hub-fab {
                width: 52px;
                height: 52px;
                font-size: 22px;
            }

            .timer-hub-panel {
                width: calc(100vw - 32px);
                max-width: 300px;
                top: 65px;
                right: 0;
                max-height: calc(100vh - 100px);
            }

            .timer-hub-panel-header {
                padding: 12px 16px 8px;
            }

            .timer-hub-panel-title {
                font-size: 14px;
            }

            .timer-hub-item {
                padding: 12px 16px;
            }

            .timer-hub-item-time {
                font-size: 18px;
            }

            .timer-hub-badge {
                top: -4px;
                right: -4px;
                min-width: 20px;
                height: 20px;
                font-size: 10px;
            }

            .timer-hub-list {
                max-height: calc(100vh - 160px);
            }
        }

        @media (max-width: 480px) {
            .timer-hub-container {
                top: 12px;
                right: 12px;
            }

            .timer-hub-fab {
                width: 48px;
                height: 48px;
                font-size: 20px;
            }

            .timer-hub-panel {
                width: calc(100vw - 24px);
                max-width: 280px;
                top: 60px;
                right: 0;
                max-height: calc(100vh - 90px);
            }

            .timer-hub-panel-title {
                font-size: 13px;
            }

            .timer-hub-item-time {
                font-size: 16px;
            }

            .timer-hub-list {
                max-height: calc(100vh - 150px);
            }
        }

        /* Focus and accessibility */
        .timer-hub-fab:focus-visible,
        .timer-hub-close:focus-visible {
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        .timer-hub-item:focus-visible {
            outline: 1px solid var(--primary-color);
            outline-offset: -1px;
            background: rgba(97, 218, 251, 0.1);
        }

        /* High contrast mode support */
        @media (prefers-contrast: high) {
            .timer-hub-fab {
                border: 2px solid var(--text-color);
            }
            
            .timer-hub-panel {
                border: 2px solid var(--text-color);
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            .timer-hub-fab,
            .timer-hub-panel,
            .timer-hub-item,
            .timer-hub-badge {
                transition: none;
                animation: none;
            }
        }

        /* Ensure widget doesn't interfere with main content */
        @media (max-height: 600px) {
            .timer-hub-panel {
                max-height: calc(100vh - 120px);
            }
            
            .timer-hub-list {
                max-height: calc(100vh - 200px);
            }
        }

        /* Landscape mode adjustments */
        @media (orientation: landscape) and (max-height: 500px) {
            .timer-hub-container {
                top: 8px;
                right: 8px;
            }
            
            .timer-hub-panel {
                max-height: calc(100vh - 80px);
                top: 55px;
            }
            
            .timer-hub-list {
                max-height: calc(100vh - 160px);
            }
        }

        /* Ensure FAB doesn't interfere with scrollbars */
        .timer-hub-container {
            margin-right: 0;
            margin-bottom: 0;
        }

        /* Add some breathing room around the FAB */
        @media (min-width: 1200px) {
            .timer-hub-container {
                right: 40px;
                top: 40px;
            }
        }

        /* Please Read Drawer Styles */
        .please-read-container {
            margin: 20px 0;
            border-radius: 12px;
            background: var(--card-bg);
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .please-read-toggle {
            width: 100%;
            padding: 16px 20px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            font-weight: 600;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
        }

        .please-read-toggle:hover {
            background: linear-gradient(135deg, #2980b9 0%, #1f6391 100%);
        }

        .toggle-arrow {
            transition: transform 0.3s ease;
            font-size: 14px;
        }

        .toggle-arrow.rotated {
            transform: rotate(180deg);
        }

        .please-read-content {
            padding: 0 20px;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
            background: rgba(52, 152, 219, 0.05);
        }

        .please-read-content.expanded {
            max-height: 300px;
            padding: 20px;
            overflow-y: auto;
        }

        /* Custom scrollbar for drawer */
        .please-read-content::-webkit-scrollbar {
            width: 8px;
        }

        .please-read-content::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
        }

        .please-read-content::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border-radius: 4px;
            transition: background 0.3s ease;
        }

        .please-read-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #2980b9 0%, #1f6391 100%);
        }

        /* Firefox scrollbar styling */
        .please-read-content {
            scrollbar-width: thin;
            scrollbar-color: #3498db rgba(255, 255, 255, 0.05);
        }

        .please-read-content p {
            margin: 0 0 16px 0;
            line-height: 1.6;
            color: var(--text-color);
        }

        .please-read-content p:last-child {
            margin-bottom: 0;
        }

        .please-read-content strong {
            color: #3498db;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Modern Timer Hub -->
        <div id="timerHubContainer" class="timer-hub-container">
            <!-- Floating Action Button -->
            <button id="timerHubFab" class="timer-hub-fab" onclick="toggleTimerHub()" aria-label="Toggle active timers" title="View active timers">
                ⏲️
                <span id="timerHubBadge" class="timer-hub-badge">0</span>
            </button>
            
            <!-- Expandable Panel -->
            <div id="timerHubPanel" class="timer-hub-panel">
                <div class="timer-hub-panel-header">
                    <h3 class="timer-hub-panel-title">Active Timers</h3>
                    <button class="timer-hub-close" onclick="toggleTimerHub()" aria-label="Close timer panel">×</button>
                </div>
                <div id="timerHubList" class="timer-hub-list">
                    <!-- Dynamic content will be inserted here -->
                </div>
            </div>
        </div>

        <div class="main-container">
            <div class="app-header">
                <img src="vta-512.png" alt="App Icon" class="app-icon" loading="lazy">
                <h1 class="app-title">Visual Appointment Reminders</h1>
            </div>
            
            <div id="currentTime"></div>
            
            <div class="form-section">
                <div class="form-row">
                    <label for="tagSelect">Appointment Type:</label>
                    <select id="tagSelect">
                        <option value="General">General</option>
                        <option value="Home Appointment">Home Appointment</option>
                        <option value="Online Appointment">Online Appointment</option>
                        <option value="Meeting">Meeting</option>
                        <option value="Travel">Travel</option>
                        <option value="Report">Report</option>
                        <option value="Service Plan">Service Plan</option>
                        <option value="Stats">Stats</option>
                        <option value="Office">Office</option>
                        <option value="Other">Other</option>
                    </select>
                </div>
                
                <div class="form-row">
                    <label for="descInput">Appointment Initials (2 letters):</label>
                    <input type="text" id="descInput" maxlength="2" placeholder="e.g., DR, MT, WK" pattern="[A-Za-z]{2}" title="Please enter exactly 2 letters">
                    <small class="field-help">Short code to identify this appointment type</small>
                    <div class="input-feedback" id="descFeedback"></div>
                </div>
                
                <div class="form-row">
                    <label for="appointmentTime">Alarm Time:</label>
                    <input type="time" id="appointmentTime" required 
                           step="60" 
                           pattern="[0-9]{2}:[0-9]{2}"
                           title="Select appointment time"
                           autocomplete="off">
                    <small class="field-help">Time when the appointment starts</small>
                    <div class="input-feedback" id="timeFeedback"></div>
                </div>
                
                <div class="reminder-section">
                    <label>Reminder Times: <span class="selected-count" id="selectedCount">(1 selected)</span></label>
                    <div class="reminder-grid">
                        <div class="reminder-item">
                            <input type="checkbox" name="reminder" id="reminder3h" value="180" data-label="3h">
                            <label for="reminder3h">
                                3h
                                <span class="checkmark">✓</span>
                            </label>
                        </div>
                        <div class="reminder-item">
                            <input type="checkbox" name="reminder" id="reminder2h" value="120" data-label="2h">
                            <label for="reminder2h">
                                2h
                                <span class="checkmark">✓</span>
                            </label>
                        </div>
                        <div class="reminder-item">
                            <input type="checkbox" name="reminder" id="reminder1h30" value="90" data-label="1.5h">
                            <label for="reminder1h30">
                                1.5h
                                <span class="checkmark">✓</span>
                            </label>
                        </div>
                        <div class="reminder-item">
                            <input type="checkbox" name="reminder" id="reminder1h" value="60" data-label="1h" checked>
                            <label for="reminder1h">
                                1h
                                <span class="checkmark">✓</span>
                            </label>
                        </div>
                        <div class="reminder-item">
                            <input type="checkbox" name="reminder" id="reminder45m" value="45" data-label="45m">
                            <label for="reminder45m">
                                45m
                                <span class="checkmark">✓</span>
                            </label>
                        </div>
                        <div class="reminder-item">
                            <input type="checkbox" name="reminder" id="reminder20m" value="20" data-label="20m">
                            <label for="reminder20m">
                                20m
                                <span class="checkmark">✓</span>
                            </label>
                        </div>
                        <div class="reminder-item">
                            <input type="checkbox" name="reminder" id="reminder15m" value="15" data-label="15m">
                            <label for="reminder15m">
                                15m
                                <span class="checkmark">✓</span>
                            </label>
                        </div>
                        <div class="reminder-item">
                            <input type="checkbox" name="reminder" id="reminder10m" value="10" data-label="10m">
                            <label for="reminder10m">
                                10m
                                <span class="checkmark">✓</span>
                            </label>
                        </div>
                        <div class="reminder-item">
                            <input type="checkbox" name="reminder" id="reminder5m" value="5" data-label="5m">
                            <label for="reminder5m">
                                5m
                                <span class="checkmark">✓</span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="warning-section">
                    <label>
                        <input type="checkbox" id="threeMinuteWarning" class="three-minute-checkbox">
                        <span class="checkbox-label">🔔 3-minute audible warning before appointment</span>
                    </label>
                    <small class="field-help">Play an alarm sound 3 minutes before the appointment starts</small>
                </div>
                
                <div class="volume-section">
                    <label>Volume Control:</label>
                    <div class="volume-controls">
                        <label for="volumeSlider">Volume:</label>
                        <input type="range" id="volumeSlider" class="volume-slider" min="0" max="100" value="80">
                        <span id="volumeValue">80%</span>
                    </div>
                </div>
                
                <div class="button-container">
                    <button class="add-button" onclick="addAppointment()">Add Appointment</button>
                    <button class="cancel-button" onclick="cancelEdit()" style="display: none;">Cancel Edit</button>
                </div>
            </div>
            
            <div class="appointments-section" id="appointmentList"></div>
        </div>
        
        <!-- Please Read Drawer -->
        <div class="please-read-container">
            <button class="please-read-toggle" onclick="togglePleaseRead()">
                📖 Please Read
                <span class="toggle-arrow" id="pleaseReadArrow">▼</span>
            </button>
            <div class="please-read-content" id="pleaseReadContent">
                <p>
                    <strong>Important:</strong> The Visual Appointment Reminders app saves data locally and may not function if your device goes to sleep. It was designed to be used as a Progressive Web App. This means it is installed through a browser like Chrome or Edge so that it has an icon to launch it. Once open, it is meant to stay open and visible on a device (i.e., leaving it open on a second computer screen as a visual reminder).
                </p>
                <p>
                    <strong>Audio Alerts:</strong> The reminder time will always create an audible alarm and notification. Optionally, you can enable a 3-minute warning alarm that will sound before the appointment starts. The appointment time itself is silent so it doesn't disturb meetings that may be beginning at that time.
                </p>
                <p>
                    <strong>Privacy:</strong> This app only stores data locally in your browser. No information you enter is transmitted online or shared with any external services. All your appointment data remains completely private on your device.
                </p>
            </div>
        </div>
    </div>

    <audio id="warningBeep" preload="auto" crossorigin="anonymous">
        <source src="https://assets.mixkit.co/active_storage/sfx/2869/2869-preview.mp3" type="audio/mpeg">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAeAy6R1++7cyMFKIHH8N6QQAoWXrLq665UFApGn97z" type="audio/wav">
    </audio>

    <audio id="alarmSound" preload="auto" crossorigin="anonymous">
        <source src="https://assets.mixkit.co/active_storage/sfx/209/209-preview.mp3" type="audio/mpeg">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmAeAy6R1++7cyMFKIHH8N6QQAoWXrLq665UFApGn97z" type="audio/wav">
    </audio>

    <script>
        // Global variables
        let appointments = [];
        let countdownIntervals = {};
        let reminderIntervals = {};
        let isDataInput = false; 
        let currentVolume = 0.8;
        let editingAppointmentId = null;
        let wakeLock = null;
        let serviceWorkerRegistration = null;
        let isAppInBackground = false;
        let backgroundSyncSupported = false;
        let selectedReminderTimes = []; // Store currently selected reminder times

        // IndexedDB Manager for offline data persistence
        class IndexedDBManager {
            constructor() {
                this.dbName = 'VisualAppointmentTimerDB';
                this.dbVersion = 1;
                this.db = null;
                this.isSupported = 'indexedDB' in window;
            }

            async init() {
                if (!this.isSupported) {
                    console.warn('IndexedDB not supported, falling back to memory storage');
                    return false;
                }

                try {
                    this.db = await this.openDatabase();
                    console.log('IndexedDB initialized successfully');
                    return true;
                } catch (error) {
                    console.error('Failed to initialize IndexedDB:', error);
                    return false;
                }
            }

            openDatabase() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);

                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => resolve(request.result);

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        // Create appointments store
                        if (!db.objectStoreNames.contains('appointments')) {
                            const appointmentStore = db.createObjectStore('appointments', { 
                                keyPath: 'id', 
                                autoIncrement: true 
                            });
                            appointmentStore.createIndex('appointmentTime', 'appointmentTime', { unique: false });
                            appointmentStore.createIndex('reminderTime', 'reminderTime', { unique: false });
                        }

                        // Create settings store
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                        }
                    };
                });
            }

            // Appointment CRUD operations
            async saveAppointment(appointment) {
                if (!this.db) return null;
                
                try {
                    const transaction = this.db.transaction(['appointments'], 'readwrite');
                    const store = transaction.objectStore('appointments');
                    const result = await this.promisifyRequest(store.add(appointment));
                    console.log('Appointment saved to IndexedDB:', result);
                    return result;
                } catch (error) {
                    console.error('Failed to save appointment:', error);
                    return null;
                }
            }

            async updateAppointment(appointment) {
                if (!this.db) return false;
                
                try {
                    const transaction = this.db.transaction(['appointments'], 'readwrite');
                    const store = transaction.objectStore('appointments');
                    await this.promisifyRequest(store.put(appointment));
                    console.log('Appointment updated in IndexedDB');
                    return true;
                } catch (error) {
                    console.error('Failed to update appointment:', error);
                    return false;
                }
            }

            async deleteAppointment(id) {
                if (!this.db) return false;
                
                try {
                    const transaction = this.db.transaction(['appointments'], 'readwrite');
                    const store = transaction.objectStore('appointments');
                    await this.promisifyRequest(store.delete(id));
                    console.log('Appointment deleted from IndexedDB');
                    return true;
                } catch (error) {
                    console.error('Failed to delete appointment:', error);
                    return false;
                }
            }

            async getAllAppointments() {
                if (!this.db) return [];
                
                try {
                    const transaction = this.db.transaction(['appointments'], 'readonly');
                    const store = transaction.objectStore('appointments');
                    const result = await this.promisifyRequest(store.getAll());
                    console.log('Loaded appointments from IndexedDB:', result.length);
                    return result;
                } catch (error) {
                    console.error('Failed to load appointments:', error);
                    return [];
                }
            }

            // Settings operations
            async saveSetting(key, value) {
                if (!this.db) return false;
                
                try {
                    const transaction = this.db.transaction(['settings'], 'readwrite');
                    const store = transaction.objectStore('settings');
                    await this.promisifyRequest(store.put({ key, value }));
                    return true;
                } catch (error) {
                    console.error('Failed to save setting:', error);
                    return false;
                }
            }

            async getSetting(key, defaultValue = null) {
                if (!this.db) return defaultValue;
                
                try {
                    const transaction = this.db.transaction(['settings'], 'readonly');
                    const store = transaction.objectStore('settings');
                    const result = await this.promisifyRequest(store.get(key));
                    return result ? result.value : defaultValue;
                } catch (error) {
                    console.error('Failed to get setting:', error);
                    return defaultValue;
                }
            }

            // Utility method to promisify IndexedDB requests
            promisifyRequest(request) {
                return new Promise((resolve, reject) => {
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            // Clear all data (for testing/reset)
            async clearAllData() {
                if (!this.db) return false;
                
                try {
                    const transaction = this.db.transaction(['appointments', 'settings'], 'readwrite');
                    await Promise.all([
                        this.promisifyRequest(transaction.objectStore('appointments').clear()),
                        this.promisifyRequest(transaction.objectStore('settings').clear())
                    ]);
                    console.log('All data cleared from IndexedDB');
                    return true;
                } catch (error) {
                    console.error('Failed to clear data:', error);
                    return false;
                }
            }

            // Export data for backup
            async exportData() {
                const appointments = await this.getAllAppointments();
                const settings = await this.getAllSettings();
                return {
                    appointments,
                    settings,
                    exportDate: new Date().toISOString(),
                    version: this.dbVersion
                };
            }

            async getAllSettings() {
                if (!this.db) return [];
                
                try {
                    const transaction = this.db.transaction(['settings'], 'readonly');
                    const store = transaction.objectStore('settings');
                    return await this.promisifyRequest(store.getAll());
                } catch (error) {
                    console.error('Failed to load settings:', error);
                    return [];
                }
            }
        }

        // PWA and background functionality
        class PWAManager {
            constructor() {
                this.isInstalled = false;
                this.deferredPrompt = null;
                this.init();
            }

            async init() {
                // Check if app is installed
                this.checkInstallStatus();
                
                // Listen for install prompt
                window.addEventListener('beforeinstallprompt', (e) => {
                    e.preventDefault();
                    this.deferredPrompt = e;
                    // Install button removed - PWA can still be installed via browser's install menu
                });

                // Listen for app installed
                window.addEventListener('appinstalled', () => {
                    this.isInstalled = true;
                    console.log('PWA installed successfully');
                });

                // Handle visibility changes for background functionality
                document.addEventListener('visibilitychange', () => {
                    isAppInBackground = document.hidden;
                    this.handleVisibilityChange();
                });

                // Initialize notification permission
                await this.requestNotificationPermission();
                
                // Setup background sync if supported
                this.setupBackgroundSync();
            }

            checkInstallStatus() {
                // Check various ways to detect if PWA is installed
                if (window.matchMedia('(display-mode: standalone)').matches || 
                    window.navigator.standalone || 
                    document.referrer.includes('android-app://')) {
                    this.isInstalled = true;
                }
            }

            async requestNotificationPermission() {
                if ('Notification' in window) {
                    const permission = await Notification.requestPermission();
                    console.log('Notification permission:', permission);
                    return permission === 'granted';
                }
                return false;
            }

            async setupBackgroundSync() {
                if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
                    backgroundSyncSupported = true;
                    console.log('Background sync supported');
                }
            }

            handleVisibilityChange() {
                if (isAppInBackground) {
                    console.log('App moved to background');
                    this.setupBackgroundAlarms();
                } else {
                    console.log('App moved to foreground');
                    this.cancelBackgroundAlarms();
                }
            }

            setupBackgroundAlarms() {
                // Enhanced background functionality for alarms
                appointments.forEach(appointment => {
                    const now = new Date();
                    const timeUntil = appointment.appointmentTime - now;
                    
                    if (timeUntil > 0) {
                        // Use service worker for background notifications
                        this.scheduleBackgroundNotification(appointment, timeUntil);
                    }
                });
            }

            async scheduleBackgroundNotification(appointment, timeUntil) {
                if (serviceWorkerRegistration && 'showNotification' in serviceWorkerRegistration) {
                    // Schedule notification through service worker
                    setTimeout(async () => {
                        if (document.hidden) {
                            await serviceWorkerRegistration.showNotification(
                                'Appointment Reminder',
                                {
                                    body: `${appointment.tag} - Time to get ready!`,
                                    icon: './vta-192.png',
                                    badge: './vta-192.png',
                                    vibrate: [200, 100, 200],
                                    tag: `appointment-${appointment.id}`,
                                    requireInteraction: true,
                                    actions: [
                                        {
                                            action: 'view',
                                            title: 'View',
                                            icon: './vta-192.png'
                                        }
                                    ]
                                }
                            );
                        }
                    }, Math.max(0, timeUntil - (60 * 60 * 1000))); // Default to 1 hour reminder
                }
            }

            cancelBackgroundAlarms() {
                // Cancel any scheduled background notifications
                if (serviceWorkerRegistration) {
                    serviceWorkerRegistration.getNotifications().then(notifications => {
                        notifications.forEach(notification => {
                            if (notification.tag.startsWith('appointment-')) {
                                notification.close();
                            }
                        });
                    });
                }
            }
        }

        // Enhanced Wake Lock Manager
        class WakeLockManager {
            constructor() {
                this.wakeLock = null;
                this.isSupported = 'wakeLock' in navigator;
                this.init();
            }

            init() {
                console.log('Wake lock supported:', this.isSupported);
                
                // Handle visibility changes
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden && this.wakeLock) {
                        this.release();
                    } else if (!document.hidden && appointments.length > 0) {
                        this.request();
                    }
                });

                // Handle page beforeunload
                window.addEventListener('beforeunload', () => {
                    this.release();
                });
            }

            async request() {
                if (!this.isSupported || this.wakeLock) return;

                try {
                    this.wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake lock acquired');
                    
                    this.wakeLock.addEventListener('release', () => {
                        console.log('Wake lock released');
                        this.wakeLock = null;
                    });
                } catch (err) {
                    console.error('Failed to acquire wake lock:', err);
                }
            }

            release() {
                if (this.wakeLock) {
                    this.wakeLock.release();
                    this.wakeLock = null;
                    console.log('Wake lock manually released');
                }
            }

            update() {
                if (appointments.length > 0) {
                    this.request();
                } else {
                    this.release();
                }
            }
        }

        // Enhanced Audio Manager for PWA
        class AudioManager {
            constructor() {
                this.warningAudio = null;
                this.alarmAudio = null;
                this.audioContext = null;
                this.isAudioReady = false;
                this.init();
            }

            async init() {
                // Initialize audio elements
                this.warningAudio = document.getElementById('warningBeep');
                this.alarmAudio = document.getElementById('alarmSound');

                // Set initial volume
                this.updateVolume(currentVolume);

                // Handle audio context for mobile browsers
                await this.initAudioContext();

                // Preload audio for better performance
                this.preloadAudio();

                // Handle audio loading
                this.warningAudio.addEventListener('canplaythrough', () => {
                    console.log('Warning audio ready');
                });

                this.alarmAudio.addEventListener('canplaythrough', () => {
                    console.log('Alarm audio ready');
                });
            }

            async initAudioContext() {
                try {
                    // Create audio context for better mobile support
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (AudioContext) {
                        this.audioContext = new AudioContext();
                        
                        // Resume audio context on first user interaction
                        const resumeAudio = async () => {
                            if (this.audioContext && this.audioContext.state === 'suspended') {
                                await this.audioContext.resume();
                                console.log('Audio context resumed');
                            }
                            document.removeEventListener('touchstart', resumeAudio);
                            document.removeEventListener('click', resumeAudio);
                        };
                        
                        document.addEventListener('touchstart', resumeAudio);
                        document.addEventListener('click', resumeAudio);
                    }
                } catch (error) {
                    console.error('Failed to initialize audio context:', error);
                }
            }

            preloadAudio() {
                // Force load audio files
                this.warningAudio.load();
                this.alarmAudio.load();
            }

            updateVolume(volume) {
                if (this.warningAudio) this.warningAudio.volume = volume;
                if (this.alarmAudio) this.alarmAudio.volume = volume;
            }

            async playWarning() {
                try {
                    // Reset audio to beginning
                    this.warningAudio.currentTime = 0;
                    
                    // Play audio
                    const playPromise = this.warningAudio.play();
                    
                    if (playPromise !== undefined) {
                        await playPromise;
                        console.log('Warning audio played successfully');
                    }
                } catch (error) {
                    console.error('Failed to play warning audio:', error);
                    // Continue silently - audio will work on next user interaction
                }
            }

            async playAlarm() {
                try {
                    // Reset audio to beginning
                    this.alarmAudio.currentTime = 0;
                    
                    // Play audio
                    const playPromise = this.alarmAudio.play();
                    
                    if (playPromise !== undefined) {
                        await playPromise;
                        console.log('Alarm audio played successfully');
                    }
                } catch (error) {
                    console.error('Failed to play alarm audio:', error);
                    // Continue silently - audio will work on next user interaction
                }
            }
        }

        // Initialize PWA managers
        const pwaManager = new PWAManager();
        const wakeLockManager = new WakeLockManager();
        const audioManager = new AudioManager();
        const dbManager = new IndexedDBManager();

        // Enhanced save functions that use IndexedDB
        async function saveAppointmentToDB(appointment) {
            if (dbManager.isSupported && dbManager.db) {
                try {
                    const id = await dbManager.saveAppointment(appointment);
                    if (id) {
                        appointment.id = id;
                    }
                    return id;
                } catch (error) {
                    console.error('Failed to save appointment to DB:', error);
                }
            }
            return null;
        }

        async function updateAppointmentInDB(appointment) {
            if (dbManager.isSupported && dbManager.db) {
                try {
                    return await dbManager.updateAppointment(appointment);
                } catch (error) {
                    console.error('Failed to update appointment in DB:', error);
                }
            }
            return false;
        }

        async function deleteAppointmentFromDB(id) {
            if (dbManager.isSupported && dbManager.db) {
                try {
                    return await dbManager.deleteAppointment(id);
                } catch (error) {
                    console.error('Failed to delete appointment from DB:', error);
                }
            }
            return false;
        }

        async function saveSettingToDB(key, value) {
            if (dbManager.isSupported && dbManager.db) {
                try {
                    return await dbManager.saveSetting(key, value);
                } catch (error) {
                    console.error('Failed to save setting to DB:', error);
                }
            }
            return false;
        }

        // Cross-Platform Notification Manager for enhanced PWA integration
        class CrossPlatformNotificationManager {
            constructor() {
                this.activeNotifications = new Map();
                this.reminderTimeouts = new Map();
                this.fiveMinuteTimeouts = new Map();
                this.threeMinuteTimeouts = new Map();
                this.countdownUpdateIntervals = new Map();
                this.isSupported = 'Notification' in window;
                this.platform = this.detectPlatform();
            }

            async init() {
                if (!this.isSupported) return;
                
                console.log(`Cross-Platform Notification Manager initialized for ${this.platform.os}`);
                
                // Platform-specific optimizations
                this.setupPlatformOptimizations();
            }

            // Enhanced platform detection
            detectPlatform() {
                const userAgent = navigator.userAgent;
                const platform = navigator.platform;
                
                let os = 'unknown';
                let browser = 'unknown';
                let isMobile = false;

                // Detect OS
                if (/iPad|iPhone|iPod/.test(userAgent) || (platform === 'MacIntel' && navigator.maxTouchPoints > 1)) {
                    os = 'ios';
                    isMobile = true;
                } else if (/Android/.test(userAgent)) {
                    os = 'android';
                    isMobile = true;
                } else if (/Windows/.test(userAgent) || /Win/.test(platform)) {
                    os = 'windows';
                } else if (/Mac/.test(userAgent) || /Mac/.test(platform)) {
                    os = 'macos';
                } else if (/Linux/.test(userAgent) || /Linux/.test(platform)) {
                    os = 'linux';
                }

                // Detect browser
                if (/Chrome/.test(userAgent) && !/Edge/.test(userAgent)) {
                    browser = 'chrome';
                } else if (/Firefox/.test(userAgent)) {
                    browser = 'firefox';
                } else if (/Safari/.test(userAgent) && !/Chrome/.test(userAgent)) {
                    browser = 'safari';
                } else if (/Edge/.test(userAgent)) {
                    browser = 'edge';
                }

                return {
                    os,
                    browser,
                    isMobile,
                    isIOS: os === 'ios',
                    isAndroid: os === 'android',
                    isWindows: os === 'windows',
                    isMacOS: os === 'macos',
                    isLinux: os === 'linux',
                    isDesktop: !isMobile
                };
            }

            // Setup platform-specific optimizations
            setupPlatformOptimizations() {
                if (this.platform.isIOS) {
                    // iOS: Longer intervals to preserve battery
                    this.countdownUpdateInterval = 60000; // 1 minute
                    this.maxNotifications = 3; // iOS limits notifications
                } else if (this.platform.isAndroid) {
                    // Android: More frequent updates, full feature support
                    this.countdownUpdateInterval = 30000; // 30 seconds
                    this.maxNotifications = 10;
                } else if (this.platform.isWindows) {
                    // Windows: Full desktop notification support
                    this.countdownUpdateInterval = 30000; // 30 seconds
                    this.maxNotifications = 15;
                    this.supportsActions = true;
                } else if (this.platform.isMacOS) {
                    // macOS: Safari-specific handling
                    this.countdownUpdateInterval = 45000; // 45 seconds
                    this.maxNotifications = 8;
                    this.supportsActions = this.platform.browser === 'chrome';
                } else if (this.platform.isLinux) {
                    // Linux: Varies by desktop environment
                    this.countdownUpdateInterval = 30000; // 30 seconds
                    this.maxNotifications = 12;
                    this.supportsActions = true;
                }
            }

            // Enhanced notification options based on platform
            getNotificationOptions(type, appointment, data = {}) {
                const baseOptions = {
                    icon: './vta-192.png',
                    badge: './vta-192.png',
                    requireInteraction: type === 'alarm' || type === 'reminder',
                    silent: type === 'countdown',
                    data: {
                        appointmentId: appointment.id,
                        type: type,
                        ...data
                    }
                };

                // Platform-specific enhancements
                if (this.platform.isDesktop) {
                    // Desktop platforms support more features
                    if (this.platform.isWindows || this.platform.isLinux || 
                        (this.platform.isMacOS && this.platform.browser === 'chrome')) {
                        baseOptions.actions = this.getActionsForType(type);
                    }
                }

                // Vibration support (mobile only, not iOS)
                if (this.platform.isAndroid && 'vibrate' in navigator) {
                    baseOptions.vibrate = this.getVibrationPattern(type);
                }

                return baseOptions;
            }

            // Get appropriate actions based on notification type and platform
            getActionsForType(type) {
                const actions = {
                    reminder: [
                        {
                            action: 'view',
                            title: '👁️ View App',
                            icon: './vta-192.png'
                        },
                        {
                            action: 'snooze',
                            title: '⏰ Snooze 5min',
                            icon: './vta-192.png'
                        }
                    ],
                    warning: [
                        {
                            action: 'view',
                            title: '👁️ View App',
                            icon: './vta-192.png'
                        },
                        {
                            action: 'prepare',
                            title: '🚀 Getting Ready',
                            icon: './vta-192.png'
                        }
                    ],
                    countdown: [
                        {
                            action: 'view',
                            title: '👁️ View',
                            icon: './vta-192.png'
                        },
                        {
                            action: 'cancel',
                            title: '❌ Cancel',
                            icon: './vta-192.png'
                        }
                    ],
                    alarm: [
                        {
                            action: 'view',
                            title: '👁️ View App',
                            icon: './vta-192.png'
                        },
                        {
                            action: 'dismiss',
                            title: '✓ Dismiss',
                            icon: './vta-192.png'
                        }
                    ]
                };

                return actions[type] || [];
            }

            // Get vibration pattern based on notification type
            getVibrationPattern(type) {
                const patterns = {
                    reminder: [200, 100, 200],
                    warning: [300, 150, 300, 150, 300],
                    alarm: [500, 200, 500, 200, 500],
                    countdown: [100] // Subtle vibration for countdown updates
                };

                return patterns[type] || [200];
            }

            // Schedule precise reminder notifications for an appointment
            scheduleAppointmentNotifications(appointment) {
                if (!this.isSupported || Notification.permission !== 'granted') return;

                const now = new Date();
                const appointmentTime = appointment.appointmentTime;
                const fiveMinuteWarningTime = new Date(appointmentTime.getTime() - (5 * 60 * 1000));
                const threeMinuteWarningTime = new Date(appointmentTime.getTime() - (3 * 60 * 1000));

                console.log(`Scheduling notifications for appointment ${appointment.id}:`);
                
                // Handle multiple reminder times
                const reminderTimes = appointment.reminderTimes || [{ minutes: 60, label: '1h' }];
                reminderTimes.forEach(reminder => {
                    const reminderTime = new Date(appointmentTime.getTime() - (reminder.minutes * 60 * 1000));
                    console.log(`- Reminder (${reminder.label}) at: ${formatTime12Hour(reminderTime)}`);
                });
                
                console.log(`- 5-minute warning at: ${formatTime12Hour(fiveMinuteWarningTime)}`);
                if (appointment.threeMinuteWarning) {
                    console.log(`- 3-minute warning at: ${formatTime12Hour(threeMinuteWarningTime)}`);
                }
                console.log(`- Appointment at: ${formatTime12Hour(appointmentTime)}`);

                // Clear any existing timeouts for this appointment
                this.clearAppointmentNotifications(appointment.id);

                // Schedule multiple reminder notifications
                const reminderTimeouts = new Map();
                reminderTimes.forEach((reminder, index) => {
                    const reminderTime = new Date(appointmentTime.getTime() - (reminder.minutes * 60 * 1000));
                    const reminderDelay = reminderTime.getTime() - now.getTime();
                    
                    if (reminderDelay > 0) {
                        const timeoutKey = `${appointment.id}-reminder-${index}`;
                        const reminderTimeout = setTimeout(() => {
                            this.sendReminderNotification(appointment, reminder);
                        }, reminderDelay);
                        reminderTimeouts.set(timeoutKey, reminderTimeout);
                        console.log(`Reminder notification (${reminder.label}) scheduled in ${Math.round(reminderDelay / 1000)}s`);
                    }
                });
                
                // Store all reminder timeouts
                this.reminderTimeouts.set(appointment.id, reminderTimeouts);

                // Schedule 5-minute warning notification (only if it's different from any reminder)
                const fiveMinuteDelay = fiveMinuteWarningTime.getTime() - now.getTime();
                const hasConflictingReminder = reminderTimes.some(reminder => {
                    const reminderDelay = (appointmentTime.getTime() - (reminder.minutes * 60 * 1000)) - now.getTime();
                    return Math.abs(fiveMinuteDelay - reminderDelay) < 60000; // Within 1 minute
                });
                
                if (fiveMinuteDelay > 0 && !hasConflictingReminder) {
                    const fiveMinuteTimeout = setTimeout(() => {
                        this.sendFiveMinuteWarning(appointment);
                    }, fiveMinuteDelay);
                    this.fiveMinuteTimeouts.set(appointment.id, fiveMinuteTimeout);
                    console.log(`5-minute warning scheduled in ${Math.round(fiveMinuteDelay / 1000)}s`);
                }

                // Schedule 3-minute warning notification (if enabled)
                if (appointment.threeMinuteWarning) {
                    const threeMinuteDelay = threeMinuteWarningTime.getTime() - now.getTime();
                    if (threeMinuteDelay > 0) {
                        const threeMinuteTimeout = setTimeout(() => {
                            this.sendThreeMinuteWarning(appointment);
                        }, threeMinuteDelay);
                        this.threeMinuteTimeouts.set(appointment.id, threeMinuteTimeout);
                        console.log(`3-minute warning scheduled in ${Math.round(threeMinuteDelay / 1000)}s`);
                    }
                }

                // Start live countdown notifications when app is backgrounded
                if (document.hidden) {
                    this.startLiveCountdown(appointment);
                }
            }

            // Send reminder notification when reminder time is reached
            async sendReminderNotification(appointment, reminderInfo = null) {
                if (!this.isSupported || Notification.permission !== 'granted') return;

                const appointmentTime12h = formatTime12Hour(appointment.appointmentTime);
                
                // Generate reminder text with better formatting
                let reminderText;
                
                if (reminderInfo) {
                    // Use the specific reminder info passed
                    const minutes = reminderInfo.minutes;
                    reminderText = this.formatReminderTime(minutes);
                } else {
                    // Fallback to old single reminder system
                    const minutes = 60;
                    reminderText = this.formatReminderTime(minutes);
                }

                // Play audio alert for reminder
                if (audioManager && audioManager.playWarning) {
                    await audioManager.playWarning();
                }

                const notificationOptions = {
                    body: `${reminderText} until your ${appointment.tag} appointment at ${appointmentTime12h}`,
                    tag: `reminder-${appointment.id}-${Date.now()}`, // Unique tag for multiple reminders
                    ...this.getNotificationOptions('reminder', appointment)
                };

                await this.showPlatformNotification(
                    `⏰ ${appointment.desc || appointment.tag} Reminder`,
                    notificationOptions,
                    appointment.id
                );

                console.log(`Reminder notification sent for appointment ${appointment.id}: ${reminderText}`);
            }

            // Helper function to format reminder time consistently
            formatReminderTime(minutes) {
                if (minutes >= 60) {
                    const hours = minutes / 60;
                    if (hours === 1) {
                        return '1 hour';
                    } else if (hours === 1.5) {
                        return '1.5 hours';
                    } else if (hours === 2) {
                        return '2 hours';
                    } else if (hours === 3) {
                        return '3 hours';
                    } else if (hours % 1 === 0) {
                        return `${hours} hours`;
                    } else {
                        return `${hours} hours`;
                    }
                } else {
                    return `${minutes} minutes`;
                }
            }

            // Send 5-minute warning notification
            async sendFiveMinuteWarning(appointment) {
                if (!this.isSupported || Notification.permission !== 'granted') return;

                const appointmentTime12h = formatTime12Hour(appointment.appointmentTime);

                const notificationOptions = {
                    body: `5 minutes until your ${appointment.tag} appointment at ${appointmentTime12h}`,
                    tag: `warning-${appointment.id}`,
                    ...this.getNotificationOptions('warning', appointment)
                };

                await this.showPlatformNotification(
                    `🚨 ${appointment.desc || appointment.tag} Soon!`,
                    notificationOptions,
                    appointment.id
                );

                console.log(`5-minute warning sent for appointment ${appointment.id}`);
            }

            // Send 3-minute warning notification with audio
            async sendThreeMinuteWarning(appointment) {
                if (!this.isSupported || Notification.permission !== 'granted') return;

                const appointmentTime12h = formatTime12Hour(appointment.appointmentTime);

                // Play audio alert for 3-minute warning
                if (audioManager && audioManager.playAlarm) {
                    await audioManager.playAlarm();
                }

                const notificationOptions = {
                    body: `3 minutes until your ${appointment.tag} appointment at ${appointmentTime12h}`,
                    tag: `three-minute-${appointment.id}`,
                    ...this.getNotificationOptions('warning', appointment)
                };

                await this.showPlatformNotification(
                    `🚨 ${appointment.desc || appointment.tag} Starting Soon!`,
                    notificationOptions,
                    appointment.id
                );

                console.log(`3-minute warning sent for appointment ${appointment.id}`);
            }

            // Start live countdown notifications (updates every 30 seconds in background)
            startLiveCountdown(appointment) {
                if (!this.isSupported || Notification.permission !== 'granted') return;

                // Clear existing countdown interval
                if (this.countdownUpdateIntervals.has(appointment.id)) {
                    clearInterval(this.countdownUpdateIntervals.get(appointment.id));
                }

                // Start countdown notification immediately
                this.updateCountdownNotification(appointment);

                // Update every 30 seconds (or 60 seconds on iOS)
                const interval = setInterval(() => {
                    const now = new Date();
                    const timeLeft = appointment.appointmentTime - now;
                    
                    if (timeLeft <= 0) {
                        this.stopLiveCountdown(appointment.id);
                        return;
                    }
                    
                    this.updateCountdownNotification(appointment);
                }, this.countdownUpdateInterval || 30000);

                this.countdownUpdateIntervals.set(appointment.id, interval);
                console.log(`Live countdown started for appointment ${appointment.id}`);
            }

            // Universal notification method that works across all platforms
            async showPlatformNotification(title, options, appointmentId) {
                try {
                    if (serviceWorkerRegistration && 'showNotification' in serviceWorkerRegistration) {
                        // Use service worker for better cross-platform support
                        await serviceWorkerRegistration.showNotification(title, options);
                    } else {
                        // Fallback to basic Notification API
                        const notification = new Notification(title, options);
                        
                        notification.onclick = () => {
                            window.focus();
                            if (appointmentId) {
                                scrollToAppointment(appointmentId);
                            }
                            notification.close();
                        };

                        // Handle notification actions if supported
                        if (notification.addEventListener) {
                            notification.addEventListener('click', () => {
                                window.focus();
                                if (appointmentId) {
                                    scrollToAppointment(appointmentId);
                                }
                            });
                        }
                    }
                } catch (error) {
                    console.error(`Failed to show ${options.data?.type || 'unknown'} notification:`, error);
                    
                    // Ultimate fallback: try basic notification without advanced features
                    try {
                        const basicNotification = new Notification(title, {
                            body: options.body,
                            icon: options.icon
                        });
                        
                        basicNotification.onclick = () => {
                            window.focus();
                            if (appointmentId) {
                                scrollToAppointment(appointmentId);
                            }
                            basicNotification.close();
                        };
                    } catch (fallbackError) {
                        console.error('Even basic notification failed:', fallbackError);
                    }
                }
            }

            // Update countdown notification with current time remaining
            async updateCountdownNotification(appointment) {
                if (!this.isSupported || Notification.permission !== 'granted') return;

                const now = new Date();
                const timeLeft = appointment.appointmentTime - now;
                
                if (timeLeft <= 0) {
                    this.removeNotification(appointment.id);
                    return;
                }

                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);

                let countdownText;
                if (hours > 0) {
                    countdownText = `${hours}h ${minutes}m remaining`;
                } else if (minutes > 0) {
                    countdownText = `${minutes}m ${seconds}s remaining`;
                } else {
                    countdownText = `${seconds}s remaining`;
                }

                const appointmentTime12h = formatTime12Hour(appointment.appointmentTime);
                
                const notificationOptions = {
                    body: `${countdownText} until ${appointment.tag} at ${appointmentTime12h}`,
                    tag: `countdown-${appointment.id}`,
                    renotify: true,
                    ...this.getNotificationOptions('countdown', appointment, { timeLeft })
                };

                await this.showPlatformNotification(
                    `⏲️ ${appointment.desc || appointment.tag} Countdown`,
                    notificationOptions,
                    appointment.id
                );
                
                this.activeNotifications.set(appointment.id, {
                    appointment: appointment,
                    lastUpdate: now
                });
            }

            // Stop live countdown notifications
            stopLiveCountdown(appointmentId) {
                if (this.countdownUpdateIntervals.has(appointmentId)) {
                    clearInterval(this.countdownUpdateIntervals.get(appointmentId));
                    this.countdownUpdateIntervals.delete(appointmentId);
                    console.log(`Live countdown stopped for appointment ${appointmentId}`);
                }
            }

            // Clear all notification timeouts for an appointment
            clearAppointmentNotifications(appointmentId) {
                // Clear multiple reminder timeouts
                if (this.reminderTimeouts.has(appointmentId)) {
                    const timeouts = this.reminderTimeouts.get(appointmentId);
                    if (timeouts instanceof Map) {
                        // Handle new structure with multiple timeouts
                        timeouts.forEach((timeout, key) => {
                            clearTimeout(timeout);
                        });
                        timeouts.clear();
                    } else {
                        // Handle old structure with single timeout
                        clearTimeout(timeouts);
                    }
                    this.reminderTimeouts.delete(appointmentId);
                }

                // Clear 5-minute warning timeout
                if (this.fiveMinuteTimeouts.has(appointmentId)) {
                    clearTimeout(this.fiveMinuteTimeouts.get(appointmentId));
                    this.fiveMinuteTimeouts.delete(appointmentId);
                }

                // Clear 3-minute warning timeout
                if (this.threeMinuteTimeouts.has(appointmentId)) {
                    clearTimeout(this.threeMinuteTimeouts.get(appointmentId));
                    this.threeMinuteTimeouts.delete(appointmentId);
                }

                // Stop live countdown
                this.stopLiveCountdown(appointmentId);

                // Remove active notification
                this.removeNotification(appointmentId);
            }

            async removeNotification(appointmentId) {
                this.activeNotifications.delete(appointmentId);
                
                try {
                    if (serviceWorkerRegistration) {
                        // Remove all notification types for this appointment
                        const tags = [
                            `countdown-${appointmentId}`,
                            `reminder-${appointmentId}`,
                            `warning-${appointmentId}`,
                            `alarm-${appointmentId}`
                        ];
                        
                        for (const tag of tags) {
                            const notifications = await serviceWorkerRegistration.getNotifications({ tag });
                            notifications.forEach(notification => notification.close());
                        }
                    }
                } catch (error) {
                    console.error('Failed to remove notification:', error);
                }
            }

            async sendAlarmNotification(appointment) {
                if (!this.isSupported || Notification.permission !== 'granted') return;

                const appointmentTime12h = formatTime12Hour(appointment.appointmentTime);
                
                const notificationOptions = {
                    body: `Your ${appointment.tag} appointment at ${appointmentTime12h} is starting NOW!`,
                    tag: `alarm-${appointment.id}`,
                    renotify: true,
                    ...this.getNotificationOptions('alarm', appointment)
                };

                await this.showPlatformNotification(
                    `🚨 ${appointment.desc || appointment.tag} TIME!`,
                    notificationOptions,
                    appointment.id
                );
            }

            startCountdownNotification(appointment) {
                // Schedule all notifications for this appointment
                this.scheduleAppointmentNotifications(appointment);
            }

            stopCountdownNotification(appointment) {
                this.clearAppointmentNotifications(appointment.id);
            }

            // Handle visibility changes
            handleVisibilityChange() {
                if (document.hidden) {
                    // App going to background - start live countdowns for selected appointments
                    appointments.forEach(appointment => {
                        if (appointment.selected) {
                            this.startLiveCountdown(appointment);
                        }
                    });
                } else {
                    // App coming to foreground - stop live countdowns
                    appointments.forEach(appointment => {
                        this.stopLiveCountdown(appointment.id);
                    });
                }
            }

            cleanup() {
                // Clear all timeouts and intervals
                this.reminderTimeouts.forEach(timeout => clearTimeout(timeout));
                this.fiveMinuteTimeouts.forEach(timeout => clearTimeout(timeout));
                this.threeMinuteTimeouts.forEach(timeout => clearTimeout(timeout));
                this.countdownUpdateIntervals.forEach(interval => clearInterval(interval));
                
                this.reminderTimeouts.clear();
                this.fiveMinuteTimeouts.clear();
                this.threeMinuteTimeouts.clear();
                this.countdownUpdateIntervals.clear();
                this.activeNotifications.clear();
            }
        }

        // Initialize Cross-Platform notification manager
        const crossPlatformNotificationManager = new CrossPlatformNotificationManager();

        // Color mapping for appointment types
        const appointmentColors = {
            'General': '#61dafb',
            'Home Appointment': '#4ade80',
            'Online Appointment': '#3b82f6',
            'Meeting': '#a855f7',
            'Travel': '#f59e0b',
            'Report': '#ef4444',
            'Service Plan': '#06b6d4',
            'Stats': '#84cc16',
            'Office': '#64748b',
            'Other': '#8b5cf6'
        };

        // Helper function to format time in 12-hour format
        function formatTime12Hour(date) {
            return date.toLocaleTimeString([], {
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
        }

        // Helper function to format multiple reminder times for display
        function formatReminderTimes(reminderTimes) {
            if (!reminderTimes || reminderTimes.length === 0) {
                return '1 hour before';
            }
            
            const formatted = reminderTimes.map(reminder => {
                const minutes = reminder.minutes;
                if (minutes >= 60) {
                    const hours = minutes / 60;
                    if (hours === 1) {
                        return '1h';
                    } else if (hours === 1.5) {
                        return '1.5h';
                    } else if (hours === 2) {
                        return '2h';
                    } else if (hours === 3) {
                        return '3h';
                    } else if (hours % 1 === 0) {
                        return `${hours}h`;
                    } else {
                        return `${hours}h`;
                    }
                } else {
                    return `${minutes}m`;
                }
            });
            
            // Smart formatting for better readability
            if (formatted.length <= 3) {
                // Short lists: use commas
                return formatted.join(', ') + ' before';
            } else if (formatted.length <= 5) {
                // Medium lists: use more compact spacing
                return formatted.join(' • ') + ' before';
            } else {
                // Long lists: show first few and count
                const first = formatted.slice(0, 3).join(', ');
                const remaining = formatted.length - 3;
                return `${first} +${remaining} more before`;
            }
        }

        // Helper function to convert 24-hour input to 12-hour display
        function format24HourInputTo12Hour(timeString) {
            if (!timeString) return '';
            const [hours, minutes] = timeString.split(':');
            const date = new Date();
            date.setHours(parseInt(hours), parseInt(minutes), 0, 0);
            return formatTime12Hour(date);
        }

        // Helper function to convert 12-hour time back to 24-hour format for input
        function convert12HourTo24Hour(time12h) {
            const [time, modifier] = time12h.split(' ');
            let [hours, minutes] = time.split(':');
            if (hours === '12') {
                hours = '00';
            }
            if (modifier === 'PM') {
                hours = parseInt(hours, 10) + 12;
            }
            return `${hours.toString().padStart(2, '0')}:${minutes}`;
        }

        // Enhanced service worker registration and initialization
        async function initializeApp() {
            // Initialize the multi-select reminder system
            initializeReminderSystem();
            
            // First initialize the database and load saved data
            try {
                // Initialize IndexedDB
                const dbInitialized = await dbManager.init();
                
                if (dbInitialized) {
                    // Load saved appointments
                    const savedAppointments = await dbManager.getAllAppointments();
                    if (savedAppointments.length > 0) {
                        appointments.splice(0, appointments.length, ...savedAppointments);
                        appointments.sort((a, b) => a.appointmentTime - b.appointmentTime);
                        updateAppointmentList();
                        
                        // Restart timers for active appointments
                        appointments.forEach(appointment => {
                            startCountdown(appointment);
                            setupReminder(appointment);
                        });
                    }
                    
                    // Load saved settings
                    const savedVolume = await dbManager.getSetting('volume', 0.8);
                    currentVolume = savedVolume;
                    
                    console.log(`Loaded ${appointments.length} appointments from storage`);
                } else {
                    console.log('Using memory storage (data will not persist)');
                }
            } catch (error) {
                console.error('Database initialization error:', error);
            }
            
            updateCurrentTime();
            setInterval(updateCurrentTime, 1000);
            
            // Register service worker with enhanced features
            if ('serviceWorker' in navigator) {
                try {
                    serviceWorkerRegistration = await navigator.serviceWorker.register('./service-worker.js');
                    console.log('Service Worker registered successfully');
                    
                    // Listen for service worker updates
                    serviceWorkerRegistration.addEventListener('updatefound', () => {
                        const newWorker = serviceWorkerRegistration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                // New version available
                                showUpdateAvailable();
                            }
                        });
                    });
                    
                    // Listen for messages from service worker
                    navigator.serviceWorker.addEventListener('message', handleServiceWorkerMessage);
                    
                } catch (error) {
                    console.error('Service Worker registration failed:', error);
                }
            }
            
            // Setup volume control with haptic feedback
            const volumeSlider = document.getElementById('volumeSlider');
            const volumeValue = document.getElementById('volumeValue');
            
            // Set initial volume from loaded settings
            volumeSlider.value = currentVolume * 100;
            volumeValue.textContent = Math.round(currentVolume * 100) + '%';
            
            volumeSlider.addEventListener('input', function() {
                currentVolume = this.value / 100;
                volumeValue.textContent = this.value + '%';
                audioManager.updateVolume(currentVolume);
                
                // Save volume setting to IndexedDB
                saveSettingToDB('volume', currentVolume);
                
                // Haptic feedback on volume change
                hapticFeedback();
            });
            
            // Initialize audio
            await audioManager.init();
            
            // Initialize Cross-Platform notification manager
            await crossPlatformNotificationManager.init();
            
            // Handle visibility changes for background notifications
            document.addEventListener('visibilitychange', function() {
                crossPlatformNotificationManager.handleVisibilityChange();
            });
            
            // Setup keyboard shortcuts
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Enter' && (e.target.id === 'appointmentTime' || document.getElementById('appointmentTime').value)) {
                    e.preventDefault();
                    addAppointment();
                }
                
                if (e.key === 'Escape' && editingAppointmentId) {
                    e.preventDefault();
                    cancelEdit();
                }
            });
            
            // Setup window resize listener for responsive countdown labels
            let resizeTimeout;
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Update responsiveness for all active appointments
                    appointments.forEach(appointment => {
                        updateCountdownResponsiveness(appointment.id);
                    });
                }, 250); // Debounce resize events
            });
            
            // Setup form change detection
            const inputFields = document.querySelectorAll('input, select');
            inputFields.forEach(input => {
                input.addEventListener('input', () => {
                    isDataInput = true;
                });
            });
            
            // Setup beforeunload warning
            window.addEventListener('beforeunload', (event) => {
                if (isDataInput) {
                    event.preventDefault();
                    event.returnValue = '';
                }
            });

            // Handle URL parameters for shortcuts
            handleURLParameters();
            
            // Setup smart defaults and Android time input helper
            setupSmartDefaults();
            setupAndroidTimeHelper();
            
            // Setup editing update listeners for real-time feedback
            setupEditingUpdateListeners();
            
            // Initialize timer hub
            setTimeout(() => {
                initializeTimerHub();
            }, 100);
        }

        // Haptic feedback function (visual animation removed)
        function hapticFeedback(intensity = 'medium') {
            if ('vibrate' in navigator) {
                const patterns = {
                    light: [10],
                    medium: [20],
                    strong: [50]
                };
                navigator.vibrate(patterns[intensity] || patterns.medium);
            }
        }

        // Enhanced form validation
        function setupFormValidation() {
            const descInput = document.getElementById('descInput');
            const timeInput = document.getElementById('appointmentTime');
            
            descInput.addEventListener('input', () => validateField(descInput));
            descInput.addEventListener('blur', () => validateField(descInput));
            timeInput.addEventListener('input', () => validateField(timeInput));
            timeInput.addEventListener('blur', () => validateField(timeInput));
        }

        function validateField(field) {
            const feedbackElement = document.getElementById(field.id.replace('Input', 'Feedback').replace('Time', 'Feedback'));
            if (!feedbackElement) return;

            let isValid = true;
            let message = '';

            if (field.id === 'descInput') {
                const value = field.value.trim();
                if (value.length === 0) {
                    isValid = false;
                    message = 'Please enter appointment initials';
                } else if (value.length !== 2) {
                    isValid = false;
                    message = 'Please enter exactly 2 letters';
                } else if (!/^[A-Za-z]{2}$/.test(value)) {
                    isValid = false;
                    message = 'Please use only letters';
                } else {
                    isValid = true;
                    message = '✓ Valid initials';
                }
            } else if (field.id === 'appointmentTime') {
                const value = field.value;
                if (!value) {
                    isValid = false;
                    message = 'Please select an appointment time';
                } else {
                    const selectedTime = new Date();
                    const [hours, minutes] = value.split(':');
                    selectedTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
                    
                    const now = new Date();
                    const timeDiff = selectedTime - now;
                    
                    if (timeDiff < 0) {
                        // Check if it's for tomorrow
                        selectedTime.setDate(selectedTime.getDate() + 1);
                        const newTimeDiff = selectedTime - now;
                        
                        if (newTimeDiff > 0) {
                            const hours = Math.floor(newTimeDiff / (1000 * 60 * 60));
                            const minutes = Math.floor((newTimeDiff % (1000 * 60 * 60)) / (1000 * 60));
                            message = `✓ Appointment at ${formatTime12Hour(selectedTime)} tomorrow (in ${hours}h ${minutes}m)`;
                        } else {
                            isValid = false;
                            message = 'Time has already passed';
                        }
                    } else {
                        const hours = Math.floor(timeDiff / (1000 * 60 * 60));
                        const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
                        
                        if (hours === 0 && minutes < 5) {
                            isValid = false;
                            message = 'Please select a time at least 5 minutes from now';
                        } else {
                            message = `✓ Appointment at ${formatTime12Hour(selectedTime)} (in ${hours}h ${minutes}m)`;
                        }
                    }
                }
            }

            feedbackElement.textContent = message;
            feedbackElement.className = `input-feedback ${isValid ? 'success' : 'error'}`;
            
            // Update field styling
            if (isValid) {
                field.classList.remove('error');
                field.classList.add('success');
            } else {
                field.classList.remove('success');
                field.classList.add('error');
            }

            return isValid;
        }

        // Specific validation functions
        function validateDescInput() {
            return validateField(document.getElementById('descInput'));
        }

        function validateTimeInput() {
            return validateField(document.getElementById('appointmentTime'));
        }

        // Enhanced URL parameter handling for shortcuts
        function handleURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('type')) {
                document.getElementById('tagSelect').value = urlParams.get('type');
            }
            if (urlParams.get('desc')) {
                document.getElementById('descInput').value = urlParams.get('desc').substring(0, 2).toUpperCase();
            }
        }

        // Smart auto-focus (no default time)
        function setupSmartDefaults() {
            // Auto-focus on first input when page loads
            setTimeout(() => {
                document.getElementById('tagSelect').focus();
            }, 500);
        }

        // Android time input helper
        function setupAndroidTimeHelper() {
            const timeInput = document.getElementById('appointmentTime');
            
            // Add change listener for Android time validation
            timeInput.addEventListener('change', function() {
                const value = this.value;
                if (value) {
                    try {
                        // Validate time format for Android
                        const [hours, minutes] = value.split(':').map(num => parseInt(num, 10));
                        
                        if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
                            showErrorMessage('Please enter a valid time');
                            this.value = '';
                            return;
                        }
                        
                        // Create a test time to ensure it's valid
                        const testTime = new Date();
                        testTime.setHours(hours, minutes, 0, 0);
                        
                        // Show feedback for users in 12-hour format
                        const feedback = document.getElementById('timeFeedback');
                        if (feedback) {
                            feedback.textContent = `✓ Time set: ${formatTime12Hour(testTime)}`;
                            feedback.className = 'input-feedback success';
                        }
                        
                    } catch (error) {
                        console.error('Time validation error:', error);
                        showErrorMessage('Invalid time format. Please try again.');
                        this.value = '';
                    }
                }
            });
            
            // Add input listener for real-time validation on Android
            timeInput.addEventListener('input', function() {
                const feedback = document.getElementById('timeFeedback');
                if (feedback && this.value) {
                    feedback.textContent = 'Validating time...';
                    feedback.className = 'input-feedback';
                }
            });
            
            // Add focus listener to help Android users
            timeInput.addEventListener('focus', function() {
                if ('vibrate' in navigator) {
                    navigator.vibrate([50]);
                }
                
                // Show help text for users
                const feedback = document.getElementById('timeFeedback');
                if (feedback && !this.value) {
                    feedback.textContent = 'Select appointment time';
                    feedback.className = 'input-feedback';
                }
            });
        }

        // Enhanced add appointment with better UX
        function addAppointment() {
            const addButton = document.querySelector('.add-button');
            const tag = document.getElementById('tagSelect').value;
            const desc = document.getElementById('descInput').value.toUpperCase().trim();
            const time = document.getElementById('appointmentTime').value;

            // Enhanced button state management
            function resetButtonState() {
                const button = document.querySelector('.add-button');
                if (button) {
                    button.classList.remove('loading');
                    button.disabled = false;
                    button.style.pointerEvents = 'auto';
                    button.style.display = 'block';
                    button.style.visibility = 'visible';
                    
                    // Ensure button text is correct
                    if (editingAppointmentId) {
                        button.textContent = 'Update Appointment';
                    } else {
                        button.textContent = 'Add Appointment';
                    }
                }
            }

            // Ensure button exists and is visible
            if (!addButton) {
                console.error('Add button not found!');
                return;
            }

            // Validate inputs
            if (!time) {
                showErrorMessage('Please set a valid appointment time.');
                document.getElementById('appointmentTime').focus();
                hapticFeedback('strong');
                resetButtonState();
                return;
            }

            if (desc && desc.length !== 2) {
                showErrorMessage('Appointment initials must be exactly 2 letters.');
                document.getElementById('descInput').focus();
                hapticFeedback('strong');
                resetButtonState();
                return;
            }

            if (desc && !/^[A-Za-z]{2}$/.test(desc)) {
                showErrorMessage('Appointment initials can only contain letters.');
                document.getElementById('descInput').focus();
                hapticFeedback('strong');
                resetButtonState();
                return;
            }

            // Show loading state
            addButton.classList.add('loading');
            addButton.disabled = true;

            try {
                // Haptic feedback for successful action
                hapticFeedback('medium');

                // Get selected reminder times (multi-select)
                const selectedReminders = getSelectedReminderTimes();
                if (selectedReminders.length === 0) {
                    showErrorMessage('Please select at least one reminder time.');
                    resetButtonState();
                    return;
                }

                // Get 3-minute warning preference
                const threeMinuteWarning = document.getElementById('threeMinuteWarning').checked;

                const now = new Date();
                
                // Enhanced time parsing for Android compatibility
                let appointmentTime;
                try {
                    // Parse the time input more reliably
                    const [hours, minutes] = time.split(':').map(num => parseInt(num, 10));
                    
                    // Create appointment time with explicit hour/minute setting
                    appointmentTime = new Date();
                    appointmentTime.setHours(hours, minutes, 0, 0);
                    
                    // If the time is in the past today, set it for tomorrow
                    if (appointmentTime <= now) {
                        appointmentTime.setDate(appointmentTime.getDate() + 1);
                    }
                } catch (error) {
                    console.error('Time parsing error:', error);
                    showErrorMessage('Invalid time format. Please select a valid time.');
                    resetButtonState();
                    return;
                }
                
                // Check if time is too soon
                const timeDiff = appointmentTime - now;
                if (timeDiff < 5 * 60 * 1000) { // Less than 5 minutes
                    showErrorMessage('Please select a time at least 5 minutes from now.');
                    resetButtonState();
                    return;
                }

            const totalDuration = appointmentTime - now;

            if (editingAppointmentId) {
                // Edit existing appointment
                const appointmentIndex = appointments.findIndex(app => app.id === editingAppointmentId);
                if (appointmentIndex !== -1) {
                    clearInterval(countdownIntervals[editingAppointmentId]);
                    clearInterval(reminderIntervals[editingAppointmentId]);

                    appointments[appointmentIndex] = {
                        id: editingAppointmentId,
                        tag: tag,
                        desc: desc || tag.substring(0, 2).toUpperCase(),
                        appointmentTime: appointmentTime,
                        reminderTimes: selectedReminders, // Now stores array of reminder times
                        threeMinuteWarning: threeMinuteWarning,
                        totalDuration: totalDuration
                    };
                    
                    // Update in IndexedDB
                    updateAppointmentInDB(appointments[appointmentIndex]);
                }
                editingAppointmentId = null;
                addButton.textContent = 'Add Appointment';
                showSuccessMessage('Appointment updated successfully!');
            } else {
                // Add new appointment
                const appointment = {
                    id: Date.now(),
                    tag: tag,
                    desc: desc || tag.substring(0, 2).toUpperCase(),
                    appointmentTime: appointmentTime,
                    reminderTimes: selectedReminders, // Now stores array of reminder times
                    threeMinuteWarning: threeMinuteWarning,
                    totalDuration: totalDuration
                };
                
                // Save to IndexedDB first, then add to memory array
                saveAppointmentToDB(appointment).then((savedId) => {
                    if (savedId) {
                        appointment.id = savedId;
                    }
                    appointments.push(appointment);
                    appointments.sort((a, b) => a.appointmentTime - b.appointmentTime);
                    updateAppointmentList();
                    updateWakeLock();
                    updatePageTitle();
                });
                
                showSuccessMessage('Appointment saved successfully!');
            }
            
            // Schedule notifications for the new/updated appointment
            if (editingAppointmentId) {
                const updatedAppointment = appointments.find(app => app.id === editingAppointmentId);
                if (updatedAppointment) {
                    crossPlatformNotificationManager.scheduleAppointmentNotifications(updatedAppointment);
                }
            } else {
                const newAppointment = appointments[appointments.length - 1];
                if (newAppointment) {
                    crossPlatformNotificationManager.scheduleAppointmentNotifications(newAppointment);
                }
            }
            
            // Clear loading state immediately
            resetButtonState();
            
            // Reset form with enhanced UX
            setTimeout(() => {
                document.getElementById('descInput').value = '';
                document.getElementById('appointmentTime').value = '';
                document.getElementById('threeMinuteWarning').checked = false;
                document.getElementById('tagSelect').focus();
            }, 100);

            isDataInput = false; // Reset form state
            
            } catch (error) {
                console.error('Error adding appointment:', error);
                showErrorMessage('Failed to add appointment. Please try again.');
                resetButtonState();
            }
        }

        function handleServiceWorkerMessage(event) {
            const { type, payload } = event.data;
            
            switch (type) {
                case 'SYNC_APPOINTMENTS':
                    console.log('Appointments synced:', payload);
                    break;
                case 'CHECK_APPOINTMENTS':
                    console.log('Background appointment check:', payload);
                    break;
            }
        }

        // Enhanced message system
        function showErrorMessage(message) {
            showMessage(message, 'error');
        }

        function showSuccessMessage(message) {
            showMessage(message, 'success');
        }

        function showMessage(message, type = 'info') {
            // Remove any existing messages
            const existingMessage = document.querySelector('.app-message');
            if (existingMessage) {
                existingMessage.remove();
            }

            const messageEl = document.createElement('div');
            messageEl.className = `app-message ${type}`;
            messageEl.innerHTML = `
                <div class="message-content">
                    <span class="message-icon">${type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️'}</span>
                    <span class="message-text">${message}</span>
                    <button class="message-close" onclick="this.parentElement.parentElement.remove()">×</button>
                </div>
            `;
            
            // Add styles if not already added
            if (!document.querySelector('.message-styles')) {
                const styles = document.createElement('style');
                styles.className = 'message-styles';
                styles.textContent = `
                    .app-message {
                        position: fixed;
                        top: 20px;
                        left: 50%;
                        transform: translateX(-50%);
                        z-index: 10000;
                        animation: slideDown 0.3s ease-out;
                        max-width: 90vw;
                        box-shadow: var(--shadow-2xl);
                    }
                    .app-message.success { background: var(--success-gradient); }
                    .app-message.error { background: var(--alarm-gradient); }
                    .app-message.info { background: var(--primary-gradient); }
                    .message-content {
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        padding: 16px 20px;
                        border-radius: var(--border-radius);
                        color: white;
                        font-weight: 600;
                        backdrop-filter: blur(10px);
                    }
                    .message-close {
                        background: none;
                        border: none;
                        color: white;
                        font-size: 20px;
                        cursor: pointer;
                        padding: 0;
                        width: 24px;
                        height: 24px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: 50%;
                        transition: background-color 0.2s ease;
                    }
                    .message-close:hover {
                        background-color: rgba(255, 255, 255, 0.2);
                    }
                `;
                document.head.appendChild(styles);
            }

            document.body.appendChild(messageEl);

            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (messageEl.parentElement) {
                    messageEl.style.animation = 'slideUp 0.3s ease-out forwards';
                    setTimeout(() => messageEl.remove(), 300);
                }
            }, 5000);

            return messageEl;
        }

        function showUpdateAvailable() {
            const updateBtn = document.createElement('button');
            updateBtn.innerHTML = '🔄 Update Available - Click to Refresh';
            updateBtn.className = 'update-button';
            updateBtn.onclick = () => {
                window.location.reload();
            };
            
            document.body.insertBefore(updateBtn, document.body.firstChild);
            
            // Auto-hide after 10 seconds
            setTimeout(() => {
                if (updateBtn.parentNode) {
                    updateBtn.remove();
                }
            }, 10000);
        }

        function handleURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const action = urlParams.get('action');
            
            if (action === 'add') {
                // Focus on the first input field
                document.getElementById('tagSelect').focus();
            }
        }

        // Helper function to get responsive countdown label
        function getResponsiveCountdownLabel(type, segmentWidth) {
            const labels = {
                hours: {
                    full: 'Hours',
                    truncated: 'Hrs',
                    short: 'H'
                },
                minutes: {
                    full: 'Minutes',
                    truncated: 'Mins',
                    short: 'M'
                },
                seconds: {
                    full: 'Seconds',
                    truncated: 'Secs',
                    short: 'S'
                }
            };

            // Determine label based on available width
            if (segmentWidth > 80) {
                return labels[type].full;
            } else if (segmentWidth > 50) {
                return labels[type].truncated;
            } else if (segmentWidth > 30) {
                return labels[type].short;
            } else {
                return ''; // No label if too narrow
            }
        }

        // Update countdown segment responsiveness
        function updateCountdownResponsiveness(appointmentId) {
            const countdownContainer = document.getElementById(`countdown-${appointmentId}`);
            if (!countdownContainer) return;

            const segments = countdownContainer.querySelectorAll('.countdown-segment');
            const containerWidth = countdownContainer.offsetWidth;
            
            segments.forEach((segment, index) => {
                const segmentWidth = segment.offsetWidth;
                const label = segment.querySelector('.countdown-label');
                
                if (!label) return;

                // Determine segment width category
                let widthCategory = 'normal';
                if (segmentWidth < 30) {
                    widthCategory = 'tiny';
                } else if (segmentWidth < 50) {
                    widthCategory = 'very-narrow';
                } else if (segmentWidth < 80) {
                    widthCategory = 'narrow';
                }

                segment.setAttribute('data-width', widthCategory);

                // Update label text based on type and available space
                const segmentType = index === 0 ? 'hours' : index === 1 ? 'minutes' : 'seconds';
                const responsiveLabel = getResponsiveCountdownLabel(segmentType, segmentWidth);
                
                if (responsiveLabel) {
                    label.textContent = responsiveLabel;
                    label.style.display = 'block';
                } else {
                    label.style.display = 'none';
                }
            });
        }

        // Helper function to scroll to specific appointment
        function scrollToAppointment(appointmentId) {
            const appointmentElement = document.getElementById(`appointment-${appointmentId}`);
            if (appointmentElement) {
                appointmentElement.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
                
                // Add highlight effect
                appointmentElement.style.animation = 'highlightPulse 2s ease-in-out';
                setTimeout(() => {
                    appointmentElement.style.animation = '';
                }, 2000);
            }
        }

        // Update wake lock management
        function updateWakeLock() {
            wakeLockManager.update();
        }

        // Update current time display
        function updateCurrentTime() {
            const now = new Date();
            document.getElementById('currentTime').textContent = `Current Time: ${formatTime12Hour(now)}`;
        }

        // Note: Enhanced addAppointment function is already defined above

        // Update appointment list display
        function updateAppointmentList() {
            const list = document.getElementById('appointmentList');
            
            if (appointments.length === 0) {
                list.innerHTML = '';
                updateTimerHub(); // Update timer hub when no appointments
                return;
            }
            
            list.innerHTML = '<h2>Appointments</h2>';
            
            appointments.forEach((app) => {
                const appointmentElement = document.createElement('div');
                appointmentElement.className = 'appointment';
                appointmentElement.id = `appointment-${app.id}`;
                
                // Get the color for this appointment type
                const appointmentColor = appointmentColors[app.tag] || '#61dafb';
                
                // Apply color coding to the appointment border
                appointmentElement.style.borderLeft = `4px solid ${appointmentColor}`;
                appointmentElement.style.boxShadow = `0 2px 8px rgba(97, 218, 251, 0.08), inset 0 0 0 1px ${appointmentColor}20`;
                
                appointmentElement.innerHTML = `
                    <div class="appointment-info">
                        <div class="appointment-details">
                            <div class="appointment-title" style="color: ${appointmentColor};">
                                <div class="type-indicator" style="background: ${appointmentColor};">${app.desc || app.tag.substring(0, 2).toUpperCase()}</div>
                                <span>${app.tag}</span>
                                ${app.desc && app.desc !== app.tag.substring(0, 2).toUpperCase() ? `<span style="opacity: 0.8;">(${app.desc})</span>` : ''}
                            </div>
                            <div class="appointment-timing">
                                <div class="timing-row">
                                    <span class="timing-label">🕐 Appointment Time:</span>
                                    <span class="timing-value">${formatTime12Hour(app.appointmentTime)}</span>
                                </div>
                                <div class="timing-row reminder-row ${(app.reminderTimes || []).length > 4 ? 'compact' : ''}">
                                    <span class="timing-label">⏰ Reminders:</span>
                                    <span class="timing-value">${formatReminderTimes(app.reminderTimes || [{ minutes: 60, label: '1h' }])}</span>
                                </div>
                                <div class="timing-row">
                                    <span class="timing-label">🔔 3-min Warning:</span>
                                    <span class="timing-value" style="color: ${app.threeMinuteWarning ? '#4ade80' : '#ef4444'};">
                                        ${app.threeMinuteWarning ? '✓ Enabled' : '✗ Disabled'}
                                    </span>
                                </div>
                                <div class="timing-row">
                                    <span class="timing-label">📅 Date:</span>
                                    <span class="timing-value">${app.appointmentTime.toLocaleDateString()}</span>
                                </div>
                            </div>
                        </div>
                        <div class="appointment-buttons">
                            <button class="edit-btn" onclick="editAppointment(${app.id})" title="Edit this appointment">
                                ✏️ <span>Edit</span>
                            </button>
                            <button class="remove-btn" onclick="handleRemoveAppointment(${app.id})" title="Remove this appointment">
                                🗑️ <span>Remove</span>
                            </button>
                        </div>
                    </div>
                    <div class="countdown-container" id="countdown-${app.id}">
                        <div class="countdown-segment hours" id="hours-${app.id}">
                            <div class="countdown-number">0</div>
                            <div class="countdown-label">Hours</div>
                        </div>
                        <div class="countdown-segment minutes" id="minutes-${app.id}">
                            <div class="countdown-number">0</div>
                            <div class="countdown-label">Minutes</div>
                        </div>
                        <div class="countdown-segment seconds" id="seconds-${app.id}">
                            <div class="countdown-number">0</div>
                            <div class="countdown-label">Seconds</div>
                        </div>
                    </div>
                    <div class="reminder-indicator" id="reminder-indicator-${app.id}"></div>
                    <div class="countdown-text" id="countdown-text-${app.id}">Loading...</div>
                `;
                list.appendChild(appointmentElement);
                
                if (!countdownIntervals[app.id]) {
                    startCountdown(app);
                }
                if (!reminderIntervals[app.id]) {
                    setReminder(app);
                }
            });
            
            // Update timer hub whenever appointment list changes
            updateTimerHub();
        }

        // Enhanced edit appointment with visual indicators
        function editAppointment(id) {
            const appointment = appointments.find(app => app.id === id);
            if (!appointment) return;
            
            // Set editing state
            editingAppointmentId = id;
            
            // Add visual indicators
            addEditingVisualIndicators(id);
            
            // Populate form fields
            document.getElementById('tagSelect').value = appointment.tag;
            document.getElementById('descInput').value = appointment.desc || '';
            
            // Set appointment time with proper formatting
            try {
                const timeString = appointment.appointmentTime.toTimeString().slice(0, 5);
                document.getElementById('appointmentTime').value = timeString;
                
                // Show user-friendly feedback
                const feedback = document.getElementById('timeFeedback');
                if (feedback) {
                    feedback.textContent = `✓ Time set: ${formatTime12Hour(appointment.appointmentTime)}`;
                    feedback.className = 'input-feedback success';
                }
            } catch (error) {
                console.error('Error setting time for edit:', error);
                showErrorMessage('Error loading appointment time. Please set the time manually.');
            }
            
            // Set reminder times
            const reminderTimes = appointment.reminderTimes || [{ minutes: 60, label: '1h' }];
            const reminderMinutes = reminderTimes.map(r => r.minutes);
            setReminderTimes(reminderMinutes);
            
            // Set 3-minute warning
            document.getElementById('threeMinuteWarning').checked = appointment.threeMinuteWarning || false;
            
            // Update buttons and form appearance
            document.querySelector('.add-button').textContent = '📝 Update Appointment';
            document.querySelector('.cancel-button').style.display = 'block';
            document.querySelector('.form-section').classList.add('editing');
            
            // Scroll to form
            document.querySelector('.form-section').scrollIntoView({ 
                behavior: 'smooth',
                block: 'center'
            });
            
            // Show success message
            showSuccessMessage(`Editing appointment: ${appointment.desc || appointment.tag}`);
        }

        // Add visual editing indicators
        function addEditingVisualIndicators(editingId) {
            // Remove previous editing indicators
            document.querySelectorAll('.appointment').forEach(el => {
                el.classList.remove('editing');
            });
            
            // Add editing class to the appointment being edited
            const editingAppointment = document.querySelector(`#appointment-${editingId}`);
            if (editingAppointment) {
                editingAppointment.classList.add('editing');
            }
        }

        // Enhanced cancel edit function
        function cancelEdit() {
            if (!editingAppointmentId) return;
            
            // Remove visual indicators
            removeEditingVisualIndicators();
            
            // Reset form
            resetFormToDefault();
            
            // Clear editing state
            editingAppointmentId = null;
            
            // Update buttons
            document.querySelector('.add-button').textContent = 'Add Appointment';
            document.querySelector('.cancel-button').style.display = 'none';
            document.querySelector('.form-section').classList.remove('editing');
            
            // Show cancellation message
            showInfoMessage('Edit cancelled');
            
            // Haptic feedback
            hapticFeedback('light');
        }

        // Remove visual editing indicators
        function removeEditingVisualIndicators() {
            document.querySelectorAll('.appointment').forEach(el => {
                el.classList.remove('editing');
            });
            document.querySelector('.form-section').classList.remove('editing');
        }

        // Reset form to default state
        function resetFormToDefault() {
            document.getElementById('tagSelect').value = 'General';
            document.getElementById('descInput').value = '';
            document.getElementById('appointmentTime').value = '';
            document.getElementById('threeMinuteWarning').checked = false;
            
            // Reset to default reminder selection (1 hour)
            setReminderTimes([60]);
            
            // Clear feedback messages
            const feedbacks = document.querySelectorAll('.input-feedback');
            feedbacks.forEach(feedback => {
                feedback.textContent = '';
                feedback.className = 'input-feedback';
            });
        }

        // Wrapper function for async removeAppointment
        function handleRemoveAppointment(id) {
            const appointment = appointments.find(app => app.id === id);
            if (!appointment) return;
            
            if (confirm(`Are you sure you want to remove the ${appointment.tag} appointment?`)) {
                removeAppointment(id).then(() => {
                    hapticFeedback('strong');
                    showSuccessMessage('Appointment removed successfully!');
                }).catch(error => {
                    console.error('Failed to remove appointment:', error);
                    showErrorMessage('Failed to remove appointment. Please try again.');
                });
            }
        }

        // Remove appointment
        async function removeAppointment(id) {
            if (editingAppointmentId === id) {
                cancelEdit();
            }
            
            // Clear all notifications for this appointment
            crossPlatformNotificationManager.clearAppointmentNotifications(id);
            
            // Remove from IndexedDB first and wait for completion
            await deleteAppointmentFromDB(id);
            
            appointments = appointments.filter(app => app.id !== id);
            clearInterval(countdownIntervals[id]);
            delete countdownIntervals[id];
            clearInterval(reminderIntervals[id]);
            delete reminderIntervals[id];
            
            updateAppointmentList();
            updateWakeLock();
            updatePageTitle();
            isDataInput = appointments.length > 0;
        }

        // Start countdown for appointment
        function startCountdown(appointment) {
            function updateCountdown() {
                const now = new Date();
                let timeLeft = appointment.appointmentTime - now;

                const hoursElement = document.getElementById(`hours-${appointment.id}`);
                const minutesElement = document.getElementById(`minutes-${appointment.id}`);
                const secondsElement = document.getElementById(`seconds-${appointment.id}`);
                const countdownText = document.getElementById(`countdown-text-${appointment.id}`);
                const reminderIndicator = document.getElementById(`reminder-indicator-${appointment.id}`);

                // Calculate reminder seconds using multiple reminders
                const reminderTimes = appointment.reminderTimes || [{ minutes: 60, label: '1h' }];
                const earliestReminderMinutes = Math.max(...reminderTimes.map(r => r.minutes));
                const reminderSeconds = earliestReminderMinutes * 60;

                if (!hoursElement || !minutesElement || !secondsElement || !countdownText || !reminderIndicator) {
                    clearInterval(countdownIntervals[appointment.id]);
                    delete countdownIntervals[appointment.id];
                    return;
                }

                const totalSeconds = Math.floor(timeLeft / 1000);
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                const seconds = totalSeconds % 60;

                // Calculate proportional widths for visual bars
                const totalDuration = appointment.totalDuration || 24 * 3600 * 1000; // Default to 24 hours
                const remainingDuration = Math.max(0, timeLeft);
                const progressPercent = Math.max(0, Math.min(100, (remainingDuration / totalDuration) * 100));

                // Calculate individual segment widths based on their contribution
                const hoursPercent = hours > 0 ? (hours / 24) * 100 : 0;
                const minutesPercent = minutes > 0 ? (minutes / 60) * (100 - hoursPercent) / 2 : 0;
                const secondsPercent = Math.max(10, 100 - hoursPercent - minutesPercent); // Ensure seconds always visible

                // Update segment widths and content
                hoursElement.style.flex = `${Math.max(0.1, hoursPercent / 100)}`;
                minutesElement.style.flex = `${Math.max(0.3, minutesPercent / 100 + 0.2)}`;
                secondsElement.style.flex = `${Math.max(0.3, secondsPercent / 100 + 0.2)}`;

                // Enhanced visual countdown segments with responsive labels
                setTimeout(() => {
                    // Get responsive labels based on current segment width
                    const hoursLabel = getResponsiveCountdownLabel('hours', hoursElement.offsetWidth);
                    const minutesLabel = getResponsiveCountdownLabel('minutes', minutesElement.offsetWidth);
                    const secondsLabel = getResponsiveCountdownLabel('seconds', secondsElement.offsetWidth);

                    hoursElement.innerHTML = `
                        <div class="countdown-number">${hours}</div>
                        <div class="countdown-label">${hoursLabel}</div>
                    `;
                    minutesElement.innerHTML = `
                        <div class="countdown-number">${minutes}</div>
                        <div class="countdown-label">${minutesLabel}</div>
                    `;
                    secondsElement.innerHTML = `
                        <div class="countdown-number">${seconds}</div>
                        <div class="countdown-label">${secondsLabel}</div>
                    `;

                    // Update responsiveness for this appointment
                    updateCountdownResponsiveness(appointment.id);
                }, 10); // Small delay to ensure layout is updated

                // Hide segments when they're zero (except seconds)
                hoursElement.style.display = hours > 0 ? 'flex' : 'none';
                minutesElement.style.display = (minutes > 0 || hours > 0) ? 'flex' : 'none';

                // Enhanced countdown text with smart formatting
                let displayText;
                if (hours > 0) {
                    displayText = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else if (minutes > 0) {
                    displayText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    displayText = `${seconds}s`;
                }

                // Enhanced visual states based on time remaining with attention animations
                countdownText.className = 'countdown-text';
                const appointmentElement = document.getElementById(`appointment-${appointment.id}`);
                
                // Remove all attention classes first
                if (appointmentElement) {
                    appointmentElement.classList.remove('in-countdown', 'shake-attention', 'urgent-attention', 'warning-attention');
                }
                
                if (totalSeconds <= 60) {
                    countdownText.classList.add('urgent');
                    countdownText.textContent = `${displayText}${editingAppointmentId === appointment.id ? ' ✏️' : ''}`;
                    if (appointmentElement) {
                        appointmentElement.style.boxShadow = '0 0 20px rgba(239, 83, 80, 0.4)';
                        appointmentElement.classList.add('urgent-attention');
                    }
                } else if (totalSeconds <= 180 && appointment.threeMinuteWarning) { // 3 minutes and warning enabled
                    countdownText.classList.add('warning');
                    countdownText.textContent = `🔔 ${displayText} (3-min warning active)${editingAppointmentId === appointment.id ? ' ✏️' : ''}`;
                    if (appointmentElement) {
                        appointmentElement.style.boxShadow = '0 0 18px rgba(255, 193, 7, 0.4)';
                        appointmentElement.classList.add('warning-attention');
                    }
                } else if (totalSeconds <= 300) { // 5 minutes
                    countdownText.classList.add('warning');
                    countdownText.textContent = `${displayText}${editingAppointmentId === appointment.id ? ' ✏️' : ''}`;
                    if (appointmentElement) {
                        appointmentElement.style.boxShadow = '0 0 15px rgba(255, 167, 38, 0.3)';
                        appointmentElement.classList.add('warning-attention');
                    }
                } else if (totalSeconds <= reminderSeconds) { // In countdown phase
                    countdownText.textContent = `${displayText}${editingAppointmentId === appointment.id ? ' ✏️' : ''}`;
                    if (appointmentElement) {
                        appointmentElement.style.boxShadow = '';
                        appointmentElement.classList.add('in-countdown');
                        
                        // Add gentle shake every 5 seconds during countdown phase
                        if (!appointment.shakeInterval) {
                            appointment.shakeInterval = setInterval(() => {
                                if (appointmentElement) {
                                    appointmentElement.classList.add('shake-attention');
                                    setTimeout(() => {
                                        if (appointmentElement) {
                                            appointmentElement.classList.remove('shake-attention');
                                        }
                                    }, 600);
                                }
                            }, 5000);
                        }
                    }
                } else {
                    // Default case: show regular countdown text
                    countdownText.textContent = `${displayText}${editingAppointmentId === appointment.id ? ' ✏️ EDITING' : ''}`;
                    if (appointmentElement) {
                        appointmentElement.style.boxShadow = '';
                        // Clear shake interval when not in countdown
                        if (appointment.shakeInterval) {
                            clearInterval(appointment.shakeInterval);
                            appointment.shakeInterval = null;
                        }
                    }
                }

                // Enhanced reminder indicator with proper animation
                const reminderProgress = Math.max(0, Math.min(100, ((reminderSeconds - totalSeconds) / reminderSeconds) * 100));
                
                // Update the pseudo-element via CSS custom property
                reminderIndicator.style.setProperty('--progress', `${reminderProgress}%`);
                
                // Apply different colors based on urgency
                if (totalSeconds <= 60) {
                    reminderIndicator.style.setProperty('--indicator-color', 'var(--alarm-gradient)');
                } else if (totalSeconds <= reminderSeconds) {
                    reminderIndicator.style.setProperty('--indicator-color', 'var(--warning-gradient)');
                } else {
                    reminderIndicator.style.setProperty('--indicator-color', 'var(--primary-gradient)');
                }

                // Trigger reminder
                if (!appointment.reminderPassed && totalSeconds <= reminderSeconds) {
                    appointment.reminderPassed = true;
                    playWarningBeep();
                    
                    // Find which reminder time was triggered
                    const triggeredReminder = reminderTimes.find(r => r.minutes === earliestReminderMinutes);
                    const reminderLabel = triggeredReminder ? triggeredReminder.label : `${earliestReminderMinutes}m`;
                    
                    showMessage(`⏰ Reminder: ${appointment.tag} appointment in ${reminderLabel}!`, 'info');
                    
                    // Enhanced notification for Android
                    if (document.hidden && Notification.permission === 'granted') {
                        showNotification(
                            `⏰ ${appointment.tag} Reminder`, 
                            `Your appointment starts in ${reminderLabel}!`,
                            { appointmentId: appointment.id }
                        );
                    }
                }
                
                // Appointment time reached
                if (timeLeft <= 0) {
                    clearInterval(countdownIntervals[appointment.id]);
                    delete countdownIntervals[appointment.id];
                    
                    // Clear shake interval when appointment ends
                    if (appointment.shakeInterval) {
                        clearInterval(appointment.shakeInterval);
                        appointment.shakeInterval = null;
                    }
                    
                    // Stop countdown notification and send alarm notification
                    crossPlatformNotificationManager.stopCountdownNotification(appointment);
                    crossPlatformNotificationManager.sendAlarmNotification(appointment);
                    
                    playAlarmSound();
                    
                    countdownText.textContent = "TIME!";
                    countdownText.className = 'countdown-text urgent';
                    
                    // Use responsive labels even for final state
                    setTimeout(() => {
                        const hoursLabel = getResponsiveCountdownLabel('hours', hoursElement.offsetWidth);
                        const minutesLabel = getResponsiveCountdownLabel('minutes', minutesElement.offsetWidth);
                        const secondsLabel = getResponsiveCountdownLabel('seconds', secondsElement.offsetWidth);

                        hoursElement.innerHTML = `<div class="countdown-number">0</div><div class="countdown-label">${hoursLabel}</div>`;
                        minutesElement.innerHTML = `<div class="countdown-number">0</div><div class="countdown-label">${minutesLabel}</div>`;
                        secondsElement.innerHTML = `<div class="countdown-number">0</div><div class="countdown-label">${secondsLabel}</div>`;
                        
                        updateCountdownResponsiveness(appointment.id);
                    }, 10);
                    
                    if (appointmentElement) {
                        appointmentElement.classList.add('past');
                        appointmentElement.style.boxShadow = '0 0 25px rgba(239, 83, 80, 0.6)';
                    }
                    
                    showMessage(`🚨 ${appointment.tag} appointment time is NOW!`, 'error');
                    
                    // Enhanced notification for Android (fallback)
                    if (document.hidden && Notification.permission === 'granted') {
                        showNotification(
                            `🚨 ${appointment.tag} Time!`, 
                            `Your appointment is starting NOW!`,
                            { appointmentId: appointment.id, requireInteraction: true }
                        );
                    }
                    
                    // Auto-remove past appointments after 5 minutes
                    setTimeout(async () => {
                        await removeAppointment(appointment.id);
                    }, 5 * 60 * 1000);
                }
                
                // Update timer hub with current countdown status - throttled for efficiency
                if (!appointment.lastTimerHubUpdate || Date.now() - appointment.lastTimerHubUpdate > 500) {
                    appointment.lastTimerHubUpdate = Date.now();
                    updateTimerHub();
                }
            }

            updateCountdown();
            countdownIntervals[appointment.id] = setInterval(updateCountdown, 1000);
        }

        // Set reminder for appointment
        function setReminder(appointment) {
            reminderIntervals[appointment.id] = setInterval(() => {
                const now = new Date();
                const timeUntilAppointment = appointment.appointmentTime - now;
                const minutesUntilAppointment = Math.floor(timeUntilAppointment / (1000 * 60));
                
                // Check against all reminder times
                const reminderTimes = appointment.reminderTimes || [{ minutes: 60, label: '1h' }];
                const shouldTrigger = reminderTimes.some(r => minutesUntilAppointment === r.minutes);
                
                if (shouldTrigger) {
                    playWarningBeep();
                    clearInterval(reminderIntervals[appointment.id]);
                    delete reminderIntervals[appointment.id];
                }
            }, 60000);
        }

        // Play warning beep with enhanced PWA support
        async function playWarningBeep() {
            // Use the audio manager
            await audioManager.playWarning();
            
            // Vibrate on mobile devices
            if ('vibrate' in navigator) {
                navigator.vibrate([200, 100, 200]);
            }
            
            // Show notification if app is in background - Android optimized
            if (document.hidden && Notification.permission === 'granted') {
                showNotification(
                    '⏰ Appointment Reminder', 
                    'Your appointment reminder time has been reached!',
                    { silent: false, requireInteraction: true }
                );
            }
        }

        // Play alarm sound with enhanced PWA support
        async function playAlarmSound() {
            // Use the audio manager
            await audioManager.playAlarm();
            
            // Stronger vibration for appointment time
            if ('vibrate' in navigator) {
                navigator.vibrate([500, 200, 500, 200, 500]);
            }
            
            // Show notification if app is in background - Android optimized
            if (document.hidden && Notification.permission === 'granted') {
                showNotification(
                    '🚨 Appointment Time!', 
                    'Your appointment time is NOW!',
                    { silent: false, requireInteraction: true, renotify: true }
                );
            }
        }

        // Enhanced notification function with Android optimizations
        async function showNotification(title, body, options = {}) {
            // Enhanced Android-compatible notification options
            const defaultOptions = {
                body: body,
                icon: './vta-192.png',
                badge: './vta-192.png',
                vibrate: [200, 100, 200, 100, 200], // Enhanced vibration pattern
                requireInteraction: true,
                tag: 'appointment-notification-' + Date.now(), // Unique tag for each notification
                renotify: true, // Force notification to show even if tag exists
                silent: false, // Ensure sound plays
                timestamp: Date.now(),
                data: {
                    timestamp: Date.now(),
                    url: window.location.href,
                    appointmentId: options.appointmentId || null
                },
                actions: [
                    {
                        action: 'view',
                        title: '👁️ View App',
                        icon: './vta-192.png'
                    },
                    {
                        action: 'dismiss',
                        title: '✖️ Dismiss',
                        icon: './vta-192.png'
                    }
                ]
            };

            // Merge custom options with defaults
            const notificationOptions = { ...defaultOptions, ...options };

            try {
                // Check if we have permission
                if (Notification.permission !== 'granted') {
                    console.warn('Notification permission not granted');
                    return;
                }

                // Try service worker first for persistent notifications
                if (serviceWorkerRegistration && 'showNotification' in serviceWorkerRegistration) {
                    console.log('Showing service worker notification:', title);
                    await serviceWorkerRegistration.showNotification(title, notificationOptions);
                } 
                // Fallback to regular notification API
                else if ('Notification' in window) {
                    console.log('Showing regular notification:', title);
                    const notification = new Notification(title, notificationOptions);
                    
                    // Enhanced Android event handling
                    notification.onclick = function(event) {
                        console.log('Notification clicked');
                        event.preventDefault();
                        window.focus();
                        if (notificationOptions.data.appointmentId) {
                            scrollToAppointment(notificationOptions.data.appointmentId);
                        }
                        notification.close();
                    };
                    
                    notification.onerror = function(error) {
                        console.error('Notification error:', error);
                    };
                    
                    // Auto-close after 10 seconds on Android
                    setTimeout(() => {
                        if (notification) {
                            notification.close();
                        }
                    }, 10000);
                }
                
                // Additional Android fallback - show in-app alert if notifications fail
                else {
                    console.warn('No notification API available, showing alert');
                    showInAppAlert(title, body);
                }
                
            } catch (error) {
                console.error('Failed to show notification:', error);
                // Fallback to in-app alert
                showInAppAlert(title, body);
            }
        }

        // In-app alert fallback for Android
        function showInAppAlert(title, body) {
            const alertContainer = document.createElement('div');
            alertContainer.className = 'android-alert-container';
            alertContainer.innerHTML = `
                <div class="android-alert">
                    <div class="android-alert-icon">🔔</div>
                    <div class="android-alert-content">
                        <div class="android-alert-title">${title}</div>
                        <div class="android-alert-body">${body}</div>
                    </div>
                    <button class="android-alert-close" onclick="this.parentElement.parentElement.remove()">×</button>
                </div>
            `;
            
            // Add styles for Android alert
            if (!document.querySelector('.android-alert-styles')) {
                const styles = document.createElement('style');
                styles.className = 'android-alert-styles';
                styles.textContent = `
                    .android-alert-container {
                        position: fixed;
                        top: 20px;
                        left: 50%;
                        transform: translateX(-50%);
                        z-index: 10000;
                        max-width: 90vw;
                        animation: slideDown 0.3s ease-out;
                    }
                    .android-alert {
                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                        color: white;
                        padding: 16px 20px;
                        border-radius: 12px;
                        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
                        display: flex;
                        align-items: center;
                        gap: 12px;
                        min-width: 300px;
                        backdrop-filter: blur(10px);
                    }
                    .android-alert-icon {
                        font-size: 24px;
                        flex-shrink: 0;
                    }
                    .android-alert-content {
                        flex: 1;
                    }
                    .android-alert-title {
                        font-weight: 700;
                        font-size: 16px;
                        margin-bottom: 4px;
                    }
                    .android-alert-body {
                        font-size: 14px;
                        opacity: 0.9;
                    }
                    .android-alert-close {
                        background: rgba(255,255,255,0.2);
                        border: none;
                        color: white;
                        border-radius: 50%;
                        width: 28px;
                        height: 28px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        cursor: pointer;
                        font-size: 18px;
                        transition: background 0.2s;
                    }
                    .android-alert-close:hover {
                        background: rgba(255,255,255,0.3);
                    }
                    @keyframes slideDown {
                        from { transform: translateX(-50%) translateY(-100%); opacity: 0; }
                        to { transform: translateX(-50%) translateY(0); opacity: 1; }
                    }
                `;
                document.head.appendChild(styles);
            }
            
            document.body.appendChild(alertContainer);
            
            // Auto-remove after 8 seconds
            setTimeout(() => {
                if (alertContainer.parentElement) {
                    alertContainer.style.animation = 'slideUp 0.3s ease-out forwards';
                    setTimeout(() => alertContainer.remove(), 300);
                }
            }, 8000);
            
            // Vibrate on Android
            if ('vibrate' in navigator) {
                navigator.vibrate([200, 100, 200, 100, 200]);
            }
        }

        // Update page title with next appointment
        function updatePageTitle() {
            if (appointments.length === 0) {
                document.title = 'Visual Appointment Timer';
                return;
            }

            const now = new Date();
            const nextAppointment = appointments.find(app => app.appointmentTime > now);
            
            if (nextAppointment) {
                const timeLeft = nextAppointment.appointmentTime - now;
                const hours = Math.floor(timeLeft / (1000 * 60 * 60));
                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                const appointmentTime12h = formatTime12Hour(nextAppointment.appointmentTime);
                document.title = `${hours}h ${minutes}m - ${nextAppointment.tag} at ${appointmentTime12h}`;
            }
        }

        // Update page title every minute
        setInterval(updatePageTitle, 60000);

        // Cancel edit function
        function cancelEdit() {
            editingAppointmentId = null;
            document.querySelector('.add-button').textContent = 'Add Appointment';
            
            // Reset form
            document.getElementById('descInput').value = '';
            document.getElementById('appointmentTime').value = '';
            document.getElementById('tagSelect').value = 'General';
            document.getElementById('reminder1h').checked = true;
            // Focus on first input
            setTimeout(() => {
                document.getElementById('tagSelect').focus();
            }, 100);
            
            showMessage('Edit cancelled', 'info');
        }

        // Edit appointment function (enhanced version)
        // Modern Timer Hub Management - Optimized
        let timerHubExpanded = false;
        let timerHubAutoHideTimeout = null;
        let timerHubUpdateThrottle = null;
        let lastTimerHubState = null;

        function toggleTimerHub() {
            timerHubExpanded = !timerHubExpanded;
            const panel = document.getElementById('timerHubPanel');
            const fab = document.getElementById('timerHubFab');
            
            if (timerHubExpanded) {
                panel.classList.add('expanded');
                fab.setAttribute('aria-expanded', 'true');
                // Auto-hide after 10 seconds if no interaction
                timerHubAutoHideTimeout = setTimeout(() => {
                    if (timerHubExpanded) {
                        toggleTimerHub();
                    }
                }, 10000);
                
                // Add haptic feedback
                triggerHapticFeedback();
            } else {
                panel.classList.remove('expanded');
                fab.setAttribute('aria-expanded', 'false');
                clearTimeout(timerHubAutoHideTimeout);
            }
        }

        function updateTimerHub() {
            // Throttle updates to prevent excessive DOM manipulation
            if (timerHubUpdateThrottle) {
                clearTimeout(timerHubUpdateThrottle);
            }
            
            timerHubUpdateThrottle = setTimeout(() => {
                performTimerHubUpdate();
            }, 100); // Update at most every 100ms
        }

        function performTimerHubUpdate() {
            const hubList = document.getElementById('timerHubList');
            const badge = document.getElementById('timerHubBadge');
            const fab = document.getElementById('timerHubFab');
            
            if (!hubList || !badge || !fab) return;
            
            // Filter active countdown appointments - Fixed logic
            const now = new Date();
            const activeTimers = appointments.filter(app => {
                const timeUntilAppointment = app.appointmentTime - now;
                
                // Calculate earliest reminder time from multiple reminders
                const reminderTimes = app.reminderTimes || [{ minutes: 60, label: '1h' }];
                const earliestReminderMinutes = Math.max(...reminderTimes.map(r => r.minutes));
                const reminderTime = new Date(app.appointmentTime.getTime() - (earliestReminderMinutes * 60 * 1000));
                const timeUntilReminder = reminderTime - now;
                
                // Show if:
                // 1. Appointment hasn't started yet (timeUntilAppointment > 0)
                // AND either:
                // 2a. Reminder hasn't triggered yet (timeUntilReminder > 0)
                // 2b. OR we're in countdown phase (reminder triggered but appointment hasn't started)
                return timeUntilAppointment > 0;
            });

            // Create state hash to avoid unnecessary updates
            const currentState = {
                count: activeTimers.length,
                hasUrgent: activeTimers.some(app => {
                    const timeUntilAppointment = app.appointmentTime - now;
                    return timeUntilAppointment <= 5 * 60 * 1000 && timeUntilAppointment > 0;
                }),
                timers: activeTimers.map(app => {
                    const timeUntilAppointment = app.appointmentTime - now;
                    const reminderTimes = app.reminderTimes || [{ minutes: 60, label: '1h' }];
                    const earliestReminderMinutes = Math.max(...reminderTimes.map(r => r.minutes));
                    const reminderTime = new Date(app.appointmentTime.getTime() - (earliestReminderMinutes * 60 * 1000));
                    const timeUntilReminder = reminderTime - now;
                    
                    return {
                        id: app.id,
                        timeLeft: Math.floor(Math.max(timeUntilReminder, timeUntilAppointment) / 1000),
                        isInCountdown: timeUntilReminder <= 0 && timeUntilAppointment > 0
                    };
                })
            };

            // Only update if state has changed
            if (lastTimerHubState && JSON.stringify(currentState) === JSON.stringify(lastTimerHubState)) {
                return;
            }
            lastTimerHubState = currentState;

            // Update badge efficiently
            requestAnimationFrame(() => {
                if (activeTimers.length > 0) {
                    badge.textContent = activeTimers.length;
                    badge.classList.add('visible');
                    fab.classList.add('has-timers');
                    
                    if (currentState.hasUrgent) {
                        badge.classList.add('urgent');
                    } else {
                        badge.classList.remove('urgent');
                    }
                } else {
                    badge.classList.remove('visible', 'urgent');
                    fab.classList.remove('has-timers');
                }

                // Update timer list only if panel is expanded
                if (timerHubExpanded) {
                    updateTimerHubList(activeTimers);
                }
            });
        }

        function updateTimerHubList(activeTimers) {
            const hubList = document.getElementById('timerHubList');
            if (!hubList) return;

            if (activeTimers.length === 0) {
                hubList.innerHTML = `
                    <div class="timer-hub-empty">
                        <div class="timer-hub-empty-icon">⏰</div>
                        <p class="timer-hub-empty-text">No active timers</p>
                    </div>
                `;
                return;
            }

            // Use DocumentFragment for better performance
            const fragment = document.createDocumentFragment();
            
            activeTimers.forEach(app => {
                const now = new Date();
                
                // Calculate reminder time properly using multiple reminders
                const reminderTimes = app.reminderTimes || [{ minutes: 60, label: '1h' }];
                const earliestReminderMinutes = Math.max(...reminderTimes.map(r => r.minutes));
                const reminderTime = new Date(app.appointmentTime.getTime() - (earliestReminderMinutes * 60 * 1000));
                const timeUntilReminder = reminderTime - now;
                const timeUntilAppointment = app.appointmentTime - now;
                
                let timeToShow, status, itemClass;
                
                // Improved logic for displaying countdown status
                if (timeUntilReminder > 0) {
                    // Before reminder time
                    timeToShow = timeUntilReminder;
                    status = 'Until Reminder';
                    itemClass = 'countdown';
                } else if (timeUntilAppointment > 0) {
                    // After reminder, before appointment (countdown phase)
                    timeToShow = timeUntilAppointment;
                    if (timeUntilAppointment <= 60 * 1000) { // 1 minute
                        status = 'Starting NOW!';
                        itemClass = 'urgent';
                    } else if (timeUntilAppointment <= 5 * 60 * 1000) { // 5 minutes
                        status = 'Starting Soon!';
                        itemClass = 'urgent';
                    } else if (timeUntilAppointment <= 15 * 60 * 1000) { // 15 minutes
                        status = 'Starting Soon';
                        itemClass = 'warning';
                    } else {
                        status = 'Countdown';
                        itemClass = 'countdown';
                    }
                } else {
                    // Past appointment time (shouldn't happen with our filter, but safety)
                    return;
                }
                
                const timeString = formatCountdownTime(timeToShow);
                const typeColor = appointmentColors[app.type] || appointmentColors[app.tag] || appointmentColors['General'];
                const description = app.desc || app.description || app.tag?.substring(0, 2).toUpperCase() || 'AP';
                
                const itemElement = document.createElement('div');
                itemElement.className = `timer-hub-item ${itemClass}`;
                itemElement.setAttribute('tabindex', '0');
                itemElement.setAttribute('role', 'button');
                itemElement.setAttribute('aria-label', `Go to ${description} appointment`);
                
                itemElement.innerHTML = `
                    <div class="timer-hub-item-indicator" style="color: ${typeColor};"></div>
                    <div class="timer-hub-item-content">
                        <div class="timer-hub-item-title">
                            <span style="background: ${typeColor}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 700;">${description}</span>
                            <span style="opacity: 0.7;">${app.type || app.tag}</span>
                        </div>
                        <div class="timer-hub-item-time">${timeString}</div>
                        <div class="timer-hub-item-status">${status}</div>
                    </div>
                `;
                
                // Add event listeners efficiently
                itemElement.addEventListener('click', () => scrollToAppointment(app.id), { passive: true });
                itemElement.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        scrollToAppointment(app.id);
                    }
                }, { passive: false });
                
                fragment.appendChild(itemElement);
            });

            // Replace content in one operation
            hubList.innerHTML = '';
            hubList.appendChild(fragment);
        }

        function scrollToAppointment(appointmentId) {
            const appointmentElement = document.getElementById(`appointment-${appointmentId}`) || 
                                      document.querySelector(`[data-appointment-id="${appointmentId}"]`);
            if (appointmentElement) {
                // Close timer hub
                if (timerHubExpanded) {
                    toggleTimerHub();
                }
                
                // Smooth scroll to appointment
                appointmentElement.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
                
                // Add temporary highlight
                appointmentElement.classList.add('shake-attention');
                setTimeout(() => {
                    appointmentElement.classList.remove('shake-attention');
                }, 600);
                
                // Haptic feedback
                triggerHapticFeedback();
            }
        }

        function formatCountdownTime(milliseconds) {
            if (milliseconds <= 0) return '00:00:00';
            
            const totalSeconds = Math.floor(milliseconds / 1000);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            if (hours > 0) {
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else {
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // Enhanced haptic feedback
        function triggerHapticFeedback(intensity = 'light') {
            if ('vibrate' in navigator) {
                const patterns = {
                    light: [10],
                    medium: [20],
                    heavy: [30]
                };
                navigator.vibrate(patterns[intensity] || patterns.light);
            }
        }

        // Auto-hide timer hub when clicking outside - Optimized
        let clickOutsideHandler = null;

        function setupTimerHubClickOutside() {
            if (clickOutsideHandler) {
                document.removeEventListener('click', clickOutsideHandler);
            }
            
            clickOutsideHandler = (e) => {
                const timerHub = document.getElementById('timerHubContainer');
                if (timerHubExpanded && timerHub && !timerHub.contains(e.target)) {
                    toggleTimerHub();
                }
            };
            
            document.addEventListener('click', clickOutsideHandler, { passive: true });
        }

        // Optimized initialization
        function initializeTimerHub() {
            updateTimerHub();
            setupTimerHubClickOutside();
            
            // Setup intersection observer for efficiency when panel is off-screen
            if ('IntersectionObserver' in window) {
                const timerHubContainer = document.getElementById('timerHubContainer');
                if (timerHubContainer) {
                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                // Timer hub is visible, enable full updates
                                if (timerHubExpanded) {
                                    updateTimerHubList(
                                        appointments.filter(app => {
                                            const now = new Date();
                                            const reminderTimes = app.reminderTimes || [{ minutes: 60, label: '1h' }];
                                            const earliestReminderMinutes = Math.max(...reminderTimes.map(r => r.minutes));
                                            const timeUntilReminder = app.appointmentTime - now - (earliestReminderMinutes * 60 * 1000);
                                            const timeUntilAppointment = app.appointmentTime - now;
                                            return timeUntilReminder > 0 || (timeUntilAppointment > 0 && timeUntilAppointment <= earliestReminderMinutes * 60 * 1000);
                                        })
                                    );
                                }
                            }
                        });
                    }, { threshold: 0.1 });
                    
                    observer.observe(timerHubContainer);
                }
            }
        }

        // Initialize the timer hub on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize timer hub with delay to ensure DOM is ready
            setTimeout(() => {
                initializeTimerHub();
                
                // Add demo state if no appointments exist
                if (appointments.length === 0) {
                    const badge = document.getElementById('timerHubBadge');
                    const fab = document.getElementById('timerHubFab');
                    if (badge && fab) {
                        // Show a demo state briefly
                        badge.textContent = '?';
                        badge.classList.add('visible');
                        fab.setAttribute('title', 'Timer hub ready - Add appointments to see active timers');
                        
                        // Remove demo state after 3 seconds
                        setTimeout(() => {
                            if (appointments.length === 0) {
                                badge.classList.remove('visible');
                                fab.setAttribute('title', 'View active timers');
                            }
                        }, 3000);
                    }
                }
            }, 100);
        });

        // Multi-select reminder system functions
        function initializeReminderSystem() {
            // Setup event listeners for all reminder checkboxes
            setupReminderEventListeners();
            
            // Update the selected count display
            updateSelectedCount();
        }

        function setupReminderEventListeners() {
            const reminderCheckboxes = document.querySelectorAll('input[name="reminder"]');
            reminderCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    updateSelectedReminderTimes();
                    updateSelectedCount();
                    hapticFeedback();
                });
            });
        }

        function updateSelectedReminderTimes() {
            selectedReminderTimes = [];
            const reminderCheckboxes = document.querySelectorAll('input[name="reminder"]:checked');
            reminderCheckboxes.forEach(checkbox => {
                selectedReminderTimes.push({
                    minutes: parseInt(checkbox.value),
                    label: checkbox.dataset.label || checkbox.nextElementSibling.textContent.replace('✓', '').trim()
                });
            });
            
            // Sort by time (shortest to longest)
            selectedReminderTimes.sort((a, b) => a.minutes - b.minutes);
        }

        function updateSelectedCount() {
            const selectedCount = document.querySelectorAll('input[name="reminder"]:checked').length;
            const countElement = document.getElementById('selectedCount');
            if (countElement) {
                countElement.textContent = `(${selectedCount} selected)`;
                countElement.style.color = selectedCount > 0 ? 'var(--primary-color)' : 'rgba(255, 255, 255, 0.6)';
            }
        }

        function getSelectedReminderTimes() {
            updateSelectedReminderTimes();
            return selectedReminderTimes.length > 0 ? selectedReminderTimes : [{ minutes: 60, label: '1h' }]; // Default to 1 hour if none selected
        }

        function setReminderTimes(reminderMinutesArray) {
            // Uncheck all reminders first
            const allCheckboxes = document.querySelectorAll('input[name="reminder"]');
            allCheckboxes.forEach(checkbox => checkbox.checked = false);
            
            // Check the specified reminders
            reminderMinutesArray.forEach(minutes => {
                const checkbox = document.querySelector(`input[name="reminder"][value="${minutes}"]`);
                if (checkbox) {
                    checkbox.checked = true;
                }
            });
            
            updateSelectedReminderTimes();
            updateSelectedCount();
            
            // Update countdown display if currently editing
            updateEditingCountdownDisplay();
        }

        // Real-time countdown update during editing
        function updateEditingCountdownDisplay() {
            if (!editingAppointmentId) return;
            
            const appointment = appointments.find(app => app.id === editingAppointmentId);
            if (!appointment) return;
            
            // Get current form values
            const timeInput = document.getElementById('appointmentTime').value;
            const threeMinuteWarning = document.getElementById('threeMinuteWarning').checked;
            const currentReminderTimes = getSelectedReminderTimes();
            
            // Update appointment timing display if time has changed
            if (timeInput) {
                try {
                    const [hours, minutes] = timeInput.split(':');
                    const newTime = new Date(appointment.appointmentTime);
                    newTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);
                    
                    // Update the timing display
                    const timingValue = document.querySelector(`#appointment-${editingAppointmentId} .timing-row:first-child .timing-value`);
                    if (timingValue) {
                        timingValue.textContent = formatTime12Hour(newTime);
                        timingValue.style.fontWeight = 'bold';
                        timingValue.style.color = '#f59e0b';  // Orange to indicate editing
                    }
                    
                    // Update reminders display
                    const remindersValue = document.querySelector(`#appointment-${editingAppointmentId} .timing-row:nth-child(2) .timing-value`);
                    if (remindersValue) {
                        remindersValue.textContent = formatReminderTimes(currentReminderTimes);
                        remindersValue.style.fontWeight = 'bold';
                        remindersValue.style.color = '#f59e0b';  // Orange to indicate editing
                    }
                    
                    // Update 3-minute warning display
                    const warningValue = document.querySelector(`#appointment-${editingAppointmentId} .timing-row:nth-child(3) .timing-value`);
                    if (warningValue) {
                        warningValue.innerHTML = `<span style="color: ${threeMinuteWarning ? '#4ade80' : '#ef4444'}; font-weight: bold;">${threeMinuteWarning ? '✓ Enabled' : '✗ Disabled'}</span>`;
                    }
                    
                } catch (error) {
                    console.error('Error updating editing display:', error);
                }
            }
        }

        // Add event listeners for real-time updates during editing
        function setupEditingUpdateListeners() {
            // Time input change
            const timeInput = document.getElementById('appointmentTime');
            if (timeInput) {
                timeInput.addEventListener('input', updateEditingCountdownDisplay);
                timeInput.addEventListener('change', updateEditingCountdownDisplay);
            }
            
            // 3-minute warning change
            const warningCheckbox = document.getElementById('threeMinuteWarning');
            if (warningCheckbox) {
                warningCheckbox.addEventListener('change', updateEditingCountdownDisplay);
            }
            
            // Reminder checkboxes change
            const reminderCheckboxes = document.querySelectorAll('input[name="reminder"]');
            reminderCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', () => {
                    updateSelectedReminderTimes();
                    updateSelectedCount();
                    updateEditingCountdownDisplay();
                });
            });
        }

        // Toggle "Please Read" drawer
        function togglePleaseRead() {
            const content = document.getElementById('pleaseReadContent');
            const arrow = document.getElementById('pleaseReadArrow');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                arrow.classList.remove('rotated');
            } else {
                content.classList.add('expanded');
                arrow.classList.add('rotated');
            }
        }

        // Initialize the app when the page loads
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>
