        // Global variables        let appointments = [];        let countdownIntervals = {};        let reminderIntervals = {};        let isDataInput = false;         let currentVolume = 0.8;        let editingAppointmentId = null;        let wakeLock = null;        let serviceWorkerRegistration = null;        let isAppInBackground = false;        let backgroundSyncSupported = false;        let selectedReminderTimes = []; // Store currently selected reminder times        // IndexedDB Manager for offline data persistence        class IndexedDBManager {            constructor() {                this.dbName = 'VisualAppointmentTimerDB';                this.dbVersion = 1;                this.db = null;                this.isSupported = 'indexedDB' in window;            }            async init() {                if (!this.isSupported) {                    console.warn('IndexedDB not supported, falling back to memory storage');                    return false;                }                try {                    this.db = await this.openDatabase();                    console.log('IndexedDB initialized successfully');                    return true;                } catch (error) {                    console.error('Failed to initialize IndexedDB:', error);                    return false;                }            }            openDatabase() {                return new Promise((resolve, reject) => {                    const request = indexedDB.open(this.dbName, this.dbVersion);                    request.onerror = () => reject(request.error);                    request.onsuccess = () => resolve(request.result);                    request.onupgradeneeded = (event) => {                        const db = event.target.result;                                                // Create appointments store                        if (!db.objectStoreNames.contains('appointments')) {                            const appointmentStore = db.createObjectStore('appointments', {                                 keyPath: 'id',                                 autoIncrement: true                             });                            appointmentStore.createIndex('appointmentTime', 'appointmentTime', { unique: false });                            appointmentStore.createIndex('reminderTime', 'reminderTime', { unique: false });                        }                        // Create settings store                        if (!db.objectStoreNames.contains('settings')) {                            db.createObjectStore('settings', { keyPath: 'key' });                        }                    };                });            }            // Appointment CRUD operations            async saveAppointment(appointment) {                if (!this.db) return null;                                try {                    const transaction = this.db.transaction(['appointments'], 'readwrite');                    const store = transaction.objectStore('appointments');                    const result = await this.promisifyRequest(store.add(appointment));                    console.log('Appointment saved to IndexedDB:', result);                    return result;                } catch (error) {                    console.error('Failed to save appointment:', error);                    return null;                }            }            async updateAppointment(appointment) {                if (!this.db) return false;                                try {                    const transaction = this.db.transaction(['appointments'], 'readwrite');                    const store = transaction.objectStore('appointments');                    await this.promisifyRequest(store.put(appointment));                    console.log('Appointment updated in IndexedDB');                    return true;                } catch (error) {                    console.error('Failed to update appointment:', error);                    return false;                }            }            async deleteAppointment(id) {                if (!this.db) return false;                                try {                    const transaction = this.db.transaction(['appointments'], 'readwrite');                    const store = transaction.objectStore('appointments');                    await this.promisifyRequest(store.delete(id));                    console.log('Appointment deleted from IndexedDB');                    return true;                } catch (error) {                    console.error('Failed to delete appointment:', error);                    return false;                }            }            async getAllAppointments() {                if (!this.db) return [];                                try {                    const transaction = this.db.transaction(['appointments'], 'readonly');                    const store = transaction.objectStore('appointments');                    const result = await this.promisifyRequest(store.getAll());                    console.log('Loaded appointments from IndexedDB:', result.length);                    return result;                } catch (error) {                    console.error('Failed to load appointments:', error);                    return [];                }            }            // Settings operations            async saveSetting(key, value) {                if (!this.db) return false;                                try {                    const transaction = this.db.transaction(['settings'], 'readwrite');                    const store = transaction.objectStore('settings');                    await this.promisifyRequest(store.put({ key, value }));                    return true;                } catch (error) {                    console.error('Failed to save setting:', error);                    return false;                }            }            async getSetting(key, defaultValue = null) {                if (!this.db) return defaultValue;                                try {                    const transaction = this.db.transaction(['settings'], 'readonly');                    const store = transaction.objectStore('settings');                    const result = await this.promisifyRequest(store.get(key));                    return result ? result.value : defaultValue;                } catch (error) {                    console.error('Failed to get setting:', error);                    return defaultValue;                }            }            // Utility method to promisify IndexedDB requests            promisifyRequest(request) {                return new Promise((resolve, reject) => {                    request.onsuccess = () => resolve(request.result);                    request.onerror = () => reject(request.error);                });            }            // Clear all data (for testing/reset)            async clearAllData() {                if (!this.db) return false;                                try {                    const transaction = this.db.transaction(['appointments', 'settings'], 'readwrite');                    await Promise.all([                        this.promisifyRequest(transaction.objectStore('appointments').clear()),                        this.promisifyRequest(transaction.objectStore('settings').clear())                    ]);                    console.log('All data cleared from IndexedDB');                    return true;                } catch (error) {                    console.error('Failed to clear data:', error);                    return false;                }            }            // Export data for backup            async exportData() {                const appointments = await this.getAllAppointments();                const settings = await this.getAllSettings();                return {                    appointments,                    settings,                    exportDate: new Date().toISOString(),                    version: this.dbVersion                };            }            async getAllSettings() {                if (!this.db) return [];                                try {                    const transaction = this.db.transaction(['settings'], 'readonly');                    const store = transaction.objectStore('settings');                    return await this.promisifyRequest(store.getAll());                } catch (error) {                    console.error('Failed to load settings:', error);                    return [];                }            }        }        // PWA and background functionality        class PWAManager {            constructor() {                this.isInstalled = false;                this.deferredPrompt = null;                this.init();            }            async init() {                // Check if app is installed                this.checkInstallStatus();                                // Listen for install prompt                window.addEventListener('beforeinstallprompt', (e) => {                    e.preventDefault();                    this.deferredPrompt = e;                    // Install button removed - PWA can still be installed via browser's install menu                });                // Listen for app installed                window.addEventListener('appinstalled', () => {                    this.isInstalled = true;                    console.log('PWA installed successfully');                });                // Handle visibility changes for background functionality                document.addEventListener('visibilitychange', () => {                    isAppInBackground = document.hidden;                    this.handleVisibilityChange();                });                // Initialize notification permission                await this.requestNotificationPermission();                                // Setup background sync if supported                this.setupBackgroundSync();            }            checkInstallStatus() {                // Check various ways to detect if PWA is installed                if (window.matchMedia('(display-mode: standalone)').matches ||                     window.navigator.standalone ||                     document.referrer.includes('android-app://')) {                    this.isInstalled = true;                }            }            async requestNotificationPermission() {                if ('Notification' in window) {                    const permission = await Notification.requestPermission();                    console.log('Notification permission:', permission);                    return permission === 'granted';                }                return false;            }            async setupBackgroundSync() {                if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {                    backgroundSyncSupported = true;                    console.log('Background sync supported');                }            }            handleVisibilityChange() {                if (isAppInBackground) {                    console.log('App moved to background');                    this.setupBackgroundAlarms();                } else {                    console.log('App moved to foreground');                    this.cancelBackgroundAlarms();                }            }            setupBackgroundAlarms() {                // Enhanced background functionality for alarms                appointments.forEach(appointment => {                    const now = new Date();                    const timeUntil = appointment.appointmentTime - now;                                        if (timeUntil > 0) {                        // Use service worker for background notifications                        this.scheduleBackgroundNotification(appointment, timeUntil);                    }                });            }            async scheduleBackgroundNotification(appointment, timeUntil) {                if (serviceWorkerRegistration && 'showNotification' in serviceWorkerRegistration) {                    // Schedule notification through service worker                    setTimeout(async () => {                        if (document.hidden) {                            await serviceWorkerRegistration.showNotification(                                'Appointment Reminder',                                {                                    body: `${appointment.tag} - Time to get ready!`,                                    icon: './vta-192.png',                                    badge: './vta-192.png',                                    vibrate: [200, 100, 200],                                    tag: `appointment-${appointment.id}`,                                    requireInteraction: true,                                    actions: [                                        {                                            action: 'view',                                            title: 'View',                                            icon: './vta-192.png'                                        }                                    ]                                }                            );                        }                    }, Math.max(0, timeUntil - (60 * 60 * 1000))); // Default to 1 hour reminder                }            }            cancelBackgroundAlarms() {                // Cancel any scheduled background notifications                if (serviceWorkerRegistration) {                    serviceWorkerRegistration.getNotifications().then(notifications => {                        notifications.forEach(notification => {                            if (notification.tag.startsWith('appointment-')) {                                notification.close();                            }                        });                    });                }            }        }        // Enhanced Wake Lock Manager        class WakeLockManager {            constructor() {                this.wakeLock = null;                this.isSupported = 'wakeLock' in navigator;                this.init();            }            init() {                console.log('Wake lock supported:', this.isSupported);                                // Handle visibility changes                document.addEventListener('visibilitychange', () => {                    if (document.hidden && this.wakeLock) {                        this.release();                    } else if (!document.hidden && appointments.length > 0) {                        this.request();                    }                });                // Handle page beforeunload                window.addEventListener('beforeunload', () => {                    this.release();                });            }            async request() {                if (!this.isSupported || this.wakeLock) return;                try {                    this.wakeLock = await navigator.wakeLock.request('screen');                    console.log('Wake lock acquired');                                        this.wakeLock.addEventListener('release', () => {                        console.log('Wake lock released');                        this.wakeLock = null;                    });                } catch (err) {                    console.error('Failed to acquire wake lock:', err);                }            }            release() {                if (this.wakeLock) {                    this.wakeLock.release();                    this.wakeLock = null;                    console.log('Wake lock manually released');                }            }            update() {                if (appointments.length > 0) {                    this.request();                } else {                    this.release();                }            }        }        // Enhanced Audio Manager for PWA        class AudioManager {            constructor() {                this.warningAudio = null;                this.alarmAudio = null;                this.audioContext = null;                this.isAudioReady = false;                this.init();            }            async init() {                // Initialize audio elements                this.warningAudio = document.getElementById('warningBeep');                this.alarmAudio = document.getElementById('alarmSound');                // Set initial volume                this.updateVolume(currentVolume);                // Handle audio context for mobile browsers                await this.initAudioContext();                // Preload audio for better performance                this.preloadAudio();                // Handle audio loading                this.warningAudio.addEventListener('canplaythrough', () => {                    console.log('Warning audio ready');                });                this.alarmAudio.addEventListener('canplaythrough', () => {                    console.log('Alarm audio ready');                });            }            async initAudioContext() {                try {                    // Create audio context for better mobile support                    const AudioContext = window.AudioContext || window.webkitAudioContext;                    if (AudioContext) {                        this.audioContext = new AudioContext();                                                // Resume audio context on first user interaction                        const resumeAudio = async () => {                            if (this.audioContext && this.audioContext.state === 'suspended') {                                await this.audioContext.resume();                                console.log('Audio context resumed');                            }                            document.removeEventListener('touchstart', resumeAudio);                            document.removeEventListener('click', resumeAudio);                        };                                                document.addEventListener('touchstart', resumeAudio);                        document.addEventListener('click', resumeAudio);                    }                } catch (error) {                    console.error('Failed to initialize audio context:', error);                }            }            preloadAudio() {                // Force load audio files                this.warningAudio.load();                this.alarmAudio.load();            }            updateVolume(volume) {                if (this.warningAudio) this.warningAudio.volume = volume;                if (this.alarmAudio) this.alarmAudio.volume = volume;            }            async playWarning() {                try {                    // Reset audio to beginning                    this.warningAudio.currentTime = 0;                                        // Play audio                    const playPromise = this.warningAudio.play();                                        if (playPromise !== undefined) {                        await playPromise;                        console.log('Warning audio played successfully');                    }                } catch (error) {                    console.error('Failed to play warning audio:', error);                    // Continue silently - audio will work on next user interaction                }            }            async playAlarm() {                try {                    // Reset audio to beginning                    this.alarmAudio.currentTime = 0;                                        // Play audio                    const playPromise = this.alarmAudio.play();                                        if (playPromise !== undefined) {                        await playPromise;                        console.log('Alarm audio played successfully');                    }                } catch (error) {                    console.error('Failed to play alarm audio:', error);                    // Continue silently - audio will work on next user interaction                }            }        }        // Initialize PWA managers        const pwaManager = new PWAManager();        const wakeLockManager = new WakeLockManager();        const audioManager = new AudioManager();        const dbManager = new IndexedDBManager();        // Enhanced save functions that use IndexedDB        async function saveAppointmentToDB(appointment) {            if (dbManager.isSupported && dbManager.db) {                try {                    const id = await dbManager.saveAppointment(appointment);                    if (id) {                        appointment.id = id;                    }                    return id;                } catch (error) {                    console.error('Failed to save appointment to DB:', error);                }            }            return null;        }        async function updateAppointmentInDB(appointment) {            if (dbManager.isSupported && dbManager.db) {                try {                    return await dbManager.updateAppointment(appointment);                } catch (error) {                    console.error('Failed to update appointment in DB:', error);                }            }            return false;        }        async function deleteAppointmentFromDB(id) {            if (dbManager.isSupported && dbManager.db) {                try {                    return await dbManager.deleteAppointment(id);                } catch (error) {                    console.error('Failed to delete appointment from DB:', error);                }            }            return false;        }        async function saveSettingToDB(key, value) {            if (dbManager.isSupported && dbManager.db) {                try {                    return await dbManager.saveSetting(key, value);                } catch (error) {                    console.error('Failed to save setting to DB:', error);                }            }            return false;        }        // Cross-Platform Notification Manager for enhanced PWA integration        class CrossPlatformNotificationManager {            constructor() {                this.activeNotifications = new Map();                this.reminderTimeouts = new Map();                this.fiveMinuteTimeouts = new Map();                this.threeMinuteTimeouts = new Map();                this.countdownUpdateIntervals = new Map();                this.isSupported = 'Notification' in window;                this.platform = this.detectPlatform();            }            async init() {                if (!this.isSupported) return;                                console.log(`Cross-Platform Notification Manager initialized for ${this.platform.os}`);                                // Platform-specific optimizations                this.setupPlatformOptimizations();            }            // Enhanced platform detection            detectPlatform() {                const userAgent = navigator.userAgent;                const platform = navigator.platform;                                let os = 'unknown';                let browser = 'unknown';                let isMobile = false;                // Detect OS                if (/iPad|iPhone|iPod/.test(userAgent) || (platform === 'MacIntel' && navigator.maxTouchPoints > 1)) {                    os = 'ios';                    isMobile = true;                } else if (/Android/.test(userAgent)) {                    os = 'android';                    isMobile = true;                } else if (/Windows/.test(userAgent) || /Win/.test(platform)) {                    os = 'windows';                } else if (/Mac/.test(userAgent) || /Mac/.test(platform)) {                    os = 'macos';                } else if (/Linux/.test(userAgent) || /Linux/.test(platform)) {                    os = 'linux';                }                // Detect browser                if (/Chrome/.test(userAgent) && !/Edge/.test(userAgent)) {                    browser = 'chrome';                } else if (/Firefox/.test(userAgent)) {                    browser = 'firefox';                } else if (/Safari/.test(userAgent) && !/Chrome/.test(userAgent)) {                    browser = 'safari';                } else if (/Edge/.test(userAgent)) {                    browser = 'edge';                }                return {                    os,                    browser,                    isMobile,                    isIOS: os === 'ios',                    isAndroid: os === 'android',                    isWindows: os === 'windows',                    isMacOS: os === 'macos',                    isLinux: os === 'linux',                    isDesktop: !isMobile                };            }            // Setup platform-specific optimizations            setupPlatformOptimizations() {                if (this.platform.isIOS) {                    // iOS: Longer intervals to preserve battery                    this.countdownUpdateInterval = 60000; // 1 minute                    this.maxNotifications = 3; // iOS limits notifications                } else if (this.platform.isAndroid) {                    // Android: More frequent updates, full feature support                    this.countdownUpdateInterval = 30000; // 30 seconds                    this.maxNotifications = 10;                } else if (this.platform.isWindows) {                    // Windows: Full desktop notification support                    this.countdownUpdateInterval = 30000; // 30 seconds                    this.maxNotifications = 15;                    this.supportsActions = true;                } else if (this.platform.isMacOS) {                    // macOS: Safari-specific handling                    this.countdownUpdateInterval = 45000; // 45 seconds                    this.maxNotifications = 8;                    this.supportsActions = this.platform.browser === 'chrome';                } else if (this.platform.isLinux) {                    // Linux: Varies by desktop environment                    this.countdownUpdateInterval = 30000; // 30 seconds                    this.maxNotifications = 12;                    this.supportsActions = true;                }            }            // Enhanced notification options based on platform            getNotificationOptions(type, appointment, data = {}) {                const baseOptions = {                    icon: './vta-192.png',                    badge: './vta-192.png',                    requireInteraction: type === 'alarm' || type === 'reminder',                    silent: type === 'countdown',                    data: {                        appointmentId: appointment.id,                        type: type,                        ...data                    }                };                // Platform-specific enhancements                if (this.platform.isDesktop) {                    // Desktop platforms support more features                    if (this.platform.isWindows || this.platform.isLinux ||                         (this.platform.isMacOS && this.platform.browser === 'chrome')) {                        baseOptions.actions = this.getActionsForType(type);                    }                }                // Vibration support (mobile only, not iOS)                if (this.platform.isAndroid && 'vibrate' in navigator) {                    baseOptions.vibrate = this.getVibrationPattern(type);                }                return baseOptions;            }            // Get appropriate actions based on notification type and platform            getActionsForType(type) {                const actions = {                    reminder: [                        {                            action: 'view',                            title: '??? View App',                            icon: './vta-192.png'                        },                        {                            action: 'snooze',                            title: '? Snooze 5min',                            icon: './vta-192.png'                        }                    ],                    warning: [                        {                            action: 'view',                            title: '??? View App',                            icon: './vta-192.png'                        },                        {                            action: 'prepare',                            title: '?? Getting Ready',                            icon: './vta-192.png'                        }                    ],                    countdown: [                        {                            action: 'view',                            title: '??? View',                            icon: './vta-192.png'                        },                        {                            action: 'cancel',                            title: '? Cancel',                            icon: './vta-192.png'                        }                    ],                    alarm: [                        {                            action: 'view',                            title: '??? View App',                            icon: './vta-192.png'                        },                        {                            action: 'dismiss',                            title: '? Dismiss',                            icon: './vta-192.png'                        }                    ]                };                return actions[type] || [];            }            // Get vibration pattern based on notification type            getVibrationPattern(type) {                const patterns = {                    reminder: [200, 100, 200],                    warning: [300, 150, 300, 150, 300],                    alarm: [500, 200, 500, 200, 500],                    countdown: [100] // Subtle vibration for countdown updates                };                return patterns[type] || [200];            }            // Schedule precise reminder notifications for an appointment            scheduleAppointmentNotifications(appointment) {                if (!this.isSupported || Notification.permission !== 'granted') return;                const now = new Date();                const appointmentTime = appointment.appointmentTime;                const fiveMinuteWarningTime = new Date(appointmentTime.getTime() - (5 * 60 * 1000));                const threeMinuteWarningTime = new Date(appointmentTime.getTime() - (3 * 60 * 1000));                console.log(`Scheduling notifications for appointment ${appointment.id}:`);                                // Handle multiple reminder times                const reminderTimes = appointment.reminderTimes || [{ minutes: 60, label: '1h' }];                reminderTimes.forEach(reminder => {                    const reminderTime = new Date(appointmentTime.getTime() - (reminder.minutes * 60 * 1000));                    console.log(`- Reminder (${reminder.label}) at: ${formatTime12Hour(reminderTime)}`);                });                                console.log(`- 5-minute warning at: ${formatTime12Hour(fiveMinuteWarningTime)}`);                if (appointment.threeMinuteWarning) {                    console.log(`- 3-minute warning at: ${formatTime12Hour(threeMinuteWarningTime)}`);                }                console.log(`- Appointment at: ${formatTime12Hour(appointmentTime)}`);                // Clear any existing timeouts for this appointment                this.clearAppointmentNotifications(appointment.id);                // Schedule multiple reminder notifications                const reminderTimeouts = new Map();                reminderTimes.forEach((reminder, index) => {                    const reminderTime = new Date(appointmentTime.getTime() - (reminder.minutes * 60 * 1000));                    const reminderDelay = reminderTime.getTime() - now.getTime();                                        if (reminderDelay > 0) {                        const timeoutKey = `${appointment.id}-reminder-${index}`;                        const reminderTimeout = setTimeout(() => {                            this.sendReminderNotification(appointment, reminder);                        }, reminderDelay);                        reminderTimeouts.set(timeoutKey, reminderTimeout);                        console.log(`Reminder notification (${reminder.label}) scheduled in ${Math.round(reminderDelay / 1000)}s`);                    }                });                                // Store all reminder timeouts                this.reminderTimeouts.set(appointment.id, reminderTimeouts);                // Schedule 5-minute warning notification (only if it's different from any reminder)                const fiveMinuteDelay = fiveMinuteWarningTime.getTime() - now.getTime();                const hasConflictingReminder = reminderTimes.some(reminder => {                    const reminderDelay = (appointmentTime.getTime() - (reminder.minutes * 60 * 1000)) - now.getTime();                    return Math.abs(fiveMinuteDelay - reminderDelay) < 60000; // Within 1 minute                });                                if (fiveMinuteDelay > 0 && !hasConflictingReminder) {                    const fiveMinuteTimeout = setTimeout(() => {                        this.sendFiveMinuteWarning(appointment);                    }, fiveMinuteDelay);                    this.fiveMinuteTimeouts.set(appointment.id, fiveMinuteTimeout);                    console.log(`5-minute warning scheduled in ${Math.round(fiveMinuteDelay / 1000)}s`);                }                // Schedule 3-minute warning notification (if enabled)                if (appointment.threeMinuteWarning) {                    const threeMinuteDelay = threeMinuteWarningTime.getTime() - now.getTime();                    if (threeMinuteDelay > 0) {                        const threeMinuteTimeout = setTimeout(() => {                            this.sendThreeMinuteWarning(appointment);                        }, threeMinuteDelay);                        this.threeMinuteTimeouts.set(appointment.id, threeMinuteTimeout);                        console.log(`3-minute warning scheduled in ${Math.round(threeMinuteDelay / 1000)}s`);                    }                }                // Start live countdown notifications when app is backgrounded                if (document.hidden) {                    this.startLiveCountdown(appointment);                }            }            // Send reminder notification when reminder time is reached            async sendReminderNotification(appointment, reminderInfo = null) {                if (!this.isSupported || Notification.permission !== 'granted') return;                const appointmentTime12h = formatTime12Hour(appointment.appointmentTime);                                // Generate reminder text with better formatting                let reminderText;                                if (reminderInfo) {                    // Use the specific reminder info passed                    const minutes = reminderInfo.minutes;                    reminderText = this.formatReminderTime(minutes);                } else {                    // Fallback to old single reminder system                    const minutes = 60;                    reminderText = this.formatReminderTime(minutes);                }                // Play audio alert for reminder                if (audioManager && audioManager.playWarning) {                    await audioManager.playWarning();                }                const notificationOptions = {                    body: `${reminderText} until your ${appointment.tag} appointment at ${appointmentTime12h}`,                    tag: `reminder-${appointment.id}-${Date.now()}`, // Unique tag for multiple reminders                    ...this.getNotificationOptions('reminder', appointment)                };                await this.showPlatformNotification(                    `? ${appointment.desc || appointment.tag} Reminder`,                    notificationOptions,                    appointment.id                );                console.log(`Reminder notification sent for appointment ${appointment.id}: ${reminderText}`);            }            // Helper function to format reminder time consistently            formatReminderTime(minutes) {                if (minutes >= 60) {                    const hours = minutes / 60;                    if (hours === 1) {                        return '1 hour';                    } else if (hours === 1.5) {                        return '1.5 hours';                    } else if (hours === 2) {                        return '2 hours';                    } else if (hours === 3) {                        return '3 hours';                    } else if (hours % 1 === 0) {                        return `${hours} hours`;                    } else {                        return `${hours} hours`;                    }                } else {                    return `${minutes} minutes`;                }            }            // Send 5-minute warning notification            async sendFiveMinuteWarning(appointment) {                if (!this.isSupported || Notification.permission !== 'granted') return;                const appointmentTime12h = formatTime12Hour(appointment.appointmentTime);                const notificationOptions = {                    body: `5 minutes until your ${appointment.tag} appointment at ${appointmentTime12h}`,                    tag: `warning-${appointment.id}`,                    ...this.getNotificationOptions('warning', appointment)                };                await this.showPlatformNotification(                    `?? ${appointment.desc || appointment.tag} Soon!`,                    notificationOptions,                    appointment.id                );                console.log(`5-minute warning sent for appointment ${appointment.id}`);            }            // Send 3-minute warning notification with audio            async sendThreeMinuteWarning(appointment) {                if (!this.isSupported || Notification.permission !== 'granted') return;                const appointmentTime12h = formatTime12Hour(appointment.appointmentTime);                // Play audio alert for 3-minute warning                if (audioManager && audioManager.playAlarm) {                    await audioManager.playAlarm();                }                const notificationOptions = {                    body: `3 minutes until your ${appointment.tag} appointment at ${appointmentTime12h}`,                    tag: `three-minute-${appointment.id}`,                    ...this.getNotificationOptions('warning', appointment)                };                await this.showPlatformNotification(                    `?? ${appointment.desc || appointment.tag} Starting Soon!`,                    notificationOptions,                    appointment.id                );                console.log(`3-minute warning sent for appointment ${appointment.id}`);            }            // Start live countdown notifications (updates every 30 seconds in background)            startLiveCountdown(appointment) {                if (!this.isSupported || Notification.permission !== 'granted') return;                // Clear existing countdown interval                if (this.countdownUpdateIntervals.has(appointment.id)) {                    clearInterval(this.countdownUpdateIntervals.get(appointment.id));                }                // Start countdown notification immediately                this.updateCountdownNotification(appointment);                // Update every 30 seconds (or 60 seconds on iOS)                const interval = setInterval(() => {                    const now = new Date();                    const timeLeft = appointment.appointmentTime - now;                                        if (timeLeft <= 0) {                        this.stopLiveCountdown(appointment.id);                        return;                    }                                        this.updateCountdownNotification(appointment);                }, this.countdownUpdateInterval || 30000);                this.countdownUpdateIntervals.set(appointment.id, interval);                console.log(`Live countdown started for appointment ${appointment.id}`);            }            // Universal notification method that works across all platforms            async showPlatformNotification(title, options, appointmentId) {                try {                    if (serviceWorkerRegistration && 'showNotification' in serviceWorkerRegistration) {                        // Use service worker for better cross-platform support                        await serviceWorkerRegistration.showNotification(title, options);                    } else {                        // Fallback to basic Notification API                        const notification = new Notification(title, options);                                                notification.onclick = () => {                            window.focus();                            if (appointmentId) {                                scrollToAppointment(appointmentId);                            }                            notification.close();                        };                        // Handle notification actions if supported                        if (notification.addEventListener) {                            notification.addEventListener('click', () => {                                window.focus();                                if (appointmentId) {                                    scrollToAppointment(appointmentId);                                }                            });                        }                    }                } catch (error) {                    console.error(`Failed to show ${options.data?.type || 'unknown'} notification:`, error);                                        // Ultimate fallback: try basic notification without advanced features                    try {                        const basicNotification = new Notification(title, {                            body: options.body,                            icon: options.icon                        });                                                basicNotification.onclick = () => {                            window.focus();                            if (appointmentId) {                                scrollToAppointment(appointmentId);                            }                            basicNotification.close();                        };                    } catch (fallbackError) {                        console.error('Even basic notification failed:', fallbackError);                    }                }            }            // Update countdown notification with current time remaining            async updateCountdownNotification(appointment) {                if (!this.isSupported || Notification.permission !== 'granted') return;                const now = new Date();                const timeLeft = appointment.appointmentTime - now;                                if (timeLeft <= 0) {                    this.removeNotification(appointment.id);                    return;                }                const hours = Math.floor(timeLeft / (1000 * 60 * 60));                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));                const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);                let countdownText;                if (hours > 0) {                    countdownText = `${hours}h ${minutes}m remaining`;                } else if (minutes > 0) {                    countdownText = `${minutes}m ${seconds}s remaining`;                } else {                    countdownText = `${seconds}s remaining`;                }                const appointmentTime12h = formatTime12Hour(appointment.appointmentTime);                                const notificationOptions = {                    body: `${countdownText} until ${appointment.tag} at ${appointmentTime12h}`,                    tag: `countdown-${appointment.id}`,                    renotify: true,                    ...this.getNotificationOptions('countdown', appointment, { timeLeft })                };                await this.showPlatformNotification(                    `?? ${appointment.desc || appointment.tag} Countdown`,                    notificationOptions,                    appointment.id                );                                this.activeNotifications.set(appointment.id, {                    appointment: appointment,                    lastUpdate: now                });            }            // Stop live countdown notifications            stopLiveCountdown(appointmentId) {                if (this.countdownUpdateIntervals.has(appointmentId)) {                    clearInterval(this.countdownUpdateIntervals.get(appointmentId));                    this.countdownUpdateIntervals.delete(appointmentId);                    console.log(`Live countdown stopped for appointment ${appointmentId}`);                }            }            // Clear all notification timeouts for an appointment            clearAppointmentNotifications(appointmentId) {                // Clear multiple reminder timeouts                if (this.reminderTimeouts.has(appointmentId)) {                    const timeouts = this.reminderTimeouts.get(appointmentId);                    if (timeouts instanceof Map) {                        // Handle new structure with multiple timeouts                        timeouts.forEach((timeout, key) => {                            clearTimeout(timeout);                        });                        timeouts.clear();                    } else {                        // Handle old structure with single timeout                        clearTimeout(timeouts);                    }                    this.reminderTimeouts.delete(appointmentId);                }                // Clear 5-minute warning timeout                if (this.fiveMinuteTimeouts.has(appointmentId)) {                    clearTimeout(this.fiveMinuteTimeouts.get(appointmentId));                    this.fiveMinuteTimeouts.delete(appointmentId);                }                // Clear 3-minute warning timeout                if (this.threeMinuteTimeouts.has(appointmentId)) {                    clearTimeout(this.threeMinuteTimeouts.get(appointmentId));                    this.threeMinuteTimeouts.delete(appointmentId);                }                // Stop live countdown                this.stopLiveCountdown(appointmentId);                // Remove active notification                this.removeNotification(appointmentId);            }            async removeNotification(appointmentId) {                this.activeNotifications.delete(appointmentId);                                try {                    if (serviceWorkerRegistration) {                        // Remove all notification types for this appointment                        const tags = [                            `countdown-${appointmentId}`,                            `reminder-${appointmentId}`,                            `warning-${appointmentId}`,                            `alarm-${appointmentId}`                        ];                                                for (const tag of tags) {                            const notifications = await serviceWorkerRegistration.getNotifications({ tag });                            notifications.forEach(notification => notification.close());                        }                    }                } catch (error) {                    console.error('Failed to remove notification:', error);                }            }            async sendAlarmNotification(appointment) {                if (!this.isSupported || Notification.permission !== 'granted') return;                const appointmentTime12h = formatTime12Hour(appointment.appointmentTime);                                const notificationOptions = {                    body: `Your ${appointment.tag} appointment at ${appointmentTime12h} is starting NOW!`,                    tag: `alarm-${appointment.id}`,                    renotify: true,                    ...this.getNotificationOptions('alarm', appointment)                };                await this.showPlatformNotification(                    `?? ${appointment.desc || appointment.tag} TIME!`,                    notificationOptions,                    appointment.id                );            }            startCountdownNotification(appointment) {                // Schedule all notifications for this appointment                this.scheduleAppointmentNotifications(appointment);            }            stopCountdownNotification(appointment) {                this.clearAppointmentNotifications(appointment.id);            }            // Handle visibility changes            handleVisibilityChange() {                if (document.hidden) {                    // App going to background - start live countdowns for selected appointments                    appointments.forEach(appointment => {                        if (appointment.selected) {                            this.startLiveCountdown(appointment);                        }                    });                } else {                    // App coming to foreground - stop live countdowns                    appointments.forEach(appointment => {                        this.stopLiveCountdown(appointment.id);                    });                }            }            cleanup() {                // Clear all timeouts and intervals                this.reminderTimeouts.forEach(timeout => clearTimeout(timeout));                this.fiveMinuteTimeouts.forEach(timeout => clearTimeout(timeout));                this.threeMinuteTimeouts.forEach(timeout => clearTimeout(timeout));                this.countdownUpdateIntervals.forEach(interval => clearInterval(interval));                                this.reminderTimeouts.clear();                this.fiveMinuteTimeouts.clear();                this.threeMinuteTimeouts.clear();                this.countdownUpdateIntervals.clear();                this.activeNotifications.clear();            }        }        // Initialize Cross-Platform notification manager        const crossPlatformNotificationManager = new CrossPlatformNotificationManager();        // Color mapping for appointment types        const appointmentColors = {            'General': '#61dafb',            'Home Appointment': '#4ade80',            'Online Appointment': '#3b82f6',            'Meeting': '#a855f7',            'Travel': '#f59e0b',            'Report': '#ef4444',            'Service Plan': '#06b6d4',            'Stats': '#84cc16',            'Office': '#64748b',            'Other': '#8b5cf6'        };        // Helper function to format time in 12-hour format        function formatTime12Hour(date) {            return date.toLocaleTimeString([], {                hour: 'numeric',                minute: '2-digit',                hour12: true            });        }        // Helper function to format multiple reminder times for display        function formatReminderTimes(reminderTimes) {            if (!reminderTimes || reminderTimes.length === 0) {                return '1 hour before';            }                        const formatted = reminderTimes.map(reminder => {                const minutes = reminder.minutes;                if (minutes >= 60) {                    const hours = minutes / 60;                    if (hours === 1) {                        return '1h';                    } else if (hours === 1.5) {                        return '1.5h';                    } else if (hours === 2) {                        return '2h';                    } else if (hours === 3) {                        return '3h';                    } else if (hours % 1 === 0) {                        return `${hours}h`;                    } else {                        return `${hours}h`;                    }                } else {                    return `${minutes}m`;                }            });                        // Smart formatting for better readability            if (formatted.length <= 3) {                // Short lists: use commas                return formatted.join(', ') + ' before';            } else if (formatted.length <= 5) {                // Medium lists: use more compact spacing                return formatted.join('  ') + ' before';            } else {                // Long lists: show first few and count                const first = formatted.slice(0, 3).join(', ');                const remaining = formatted.length - 3;                return `${first} +${remaining} more before`;            }        }        // Helper function to convert 24-hour input to 12-hour display        function format24HourInputTo12Hour(timeString) {            if (!timeString) return '';            const [hours, minutes] = timeString.split(':');            const date = new Date();            date.setHours(parseInt(hours), parseInt(minutes), 0, 0);            return formatTime12Hour(date);        }        // Helper function to convert 12-hour time back to 24-hour format for input        function convert12HourTo24Hour(time12h) {            const [time, modifier] = time12h.split(' ');            let [hours, minutes] = time.split(':');            if (hours === '12') {                hours = '00';            }            if (modifier === 'PM') {                hours = parseInt(hours, 10) + 12;            }            return `${hours.toString().padStart(2, '0')}:${minutes}`;        }        // Enhanced service worker registration and initialization        async function initializeApp() {            // Initialize the multi-select reminder system            initializeReminderSystem();                        // First initialize the database and load saved data            try {                // Initialize IndexedDB                const dbInitialized = await dbManager.init();                                if (dbInitialized) {                    // Load saved appointments                    const savedAppointments = await dbManager.getAllAppointments();                    if (savedAppointments.length > 0) {                        appointments.splice(0, appointments.length, ...savedAppointments);                        appointments.sort((a, b) => a.appointmentTime - b.appointmentTime);                        updateAppointmentList();                                                // Restart timers for active appointments                        appointments.forEach(appointment => {                            startCountdown(appointment);                            setupReminder(appointment);                        });                    }                                        // Load saved settings                    const savedVolume = await dbManager.getSetting('volume', 0.8);                    currentVolume = savedVolume;                                        console.log(`Loaded ${appointments.length} appointments from storage`);                } else {                    console.log('Using memory storage (data will not persist)');                }            } catch (error) {                console.error('Database initialization error:', error);            }                        updateCurrentTime();            setInterval(updateCurrentTime, 1000);                        // Register service worker with enhanced features            if ('serviceWorker' in navigator) {                try {                    serviceWorkerRegistration = await navigator.serviceWorker.register('./service-worker.js');                    console.log('Service Worker registered successfully');                                        // Listen for service worker updates                    serviceWorkerRegistration.addEventListener('updatefound', () => {                        const newWorker = serviceWorkerRegistration.installing;                        newWorker.addEventListener('statechange', () => {                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {                                // New version available                                showUpdateAvailable();                            }                        });                    });                                        // Listen for messages from service worker                    navigator.serviceWorker.addEventListener('message', handleServiceWorkerMessage);                                    } catch (error) {                    console.error('Service Worker registration failed:', error);                }            }                        // Setup volume control with haptic feedback            const volumeSlider = document.getElementById('volumeSlider');            const volumeValue = document.getElementById('volumeValue');                        // Set initial volume from loaded settings            volumeSlider.value = currentVolume * 100;            volumeValue.textContent = Math.round(currentVolume * 100) + '%';                        volumeSlider.addEventListener('input', function() {                currentVolume = this.value / 100;                volumeValue.textContent = this.value + '%';                audioManager.updateVolume(currentVolume);                                // Save volume setting to IndexedDB                saveSettingToDB('volume', currentVolume);                                // Haptic feedback on volume change                hapticFeedback();            });                        // Initialize audio            await audioManager.init();                        // Initialize Cross-Platform notification manager            await crossPlatformNotificationManager.init();                        // Handle visibility changes for background notifications            document.addEventListener('visibilitychange', function() {                crossPlatformNotificationManager.handleVisibilityChange();            });                        // Setup keyboard shortcuts            document.addEventListener('keydown', function(e) {                if (e.key === 'Enter' && (e.target.id === 'appointmentTime' || document.getElementById('appointmentTime').value)) {                    e.preventDefault();                    addAppointment();                }                                if (e.key === 'Escape' && editingAppointmentId) {                    e.preventDefault();                    cancelEdit();                }            });                        // Setup window resize listener for responsive countdown labels            let resizeTimeout;            window.addEventListener('resize', function() {                clearTimeout(resizeTimeout);                resizeTimeout = setTimeout(() => {                    // Update responsiveness for all active appointments                    appointments.forEach(appointment => {                        updateCountdownResponsiveness(appointment.id);                    });                }, 250); // Debounce resize events            });                        // Setup form change detection            const inputFields = document.querySelectorAll('input, select');            inputFields.forEach(input => {                input.addEventListener('input', () => {                    isDataInput = true;                });            });                        // Setup beforeunload warning            window.addEventListener('beforeunload', (event) => {                if (isDataInput) {                    event.preventDefault();                    event.returnValue = '';                }            });            // Handle URL parameters for shortcuts            handleURLParameters();                        // Setup smart defaults and Android time input helper            setupSmartDefaults();            setupAndroidTimeHelper();                        // Setup editing update listeners for real-time feedback            setupEditingUpdateListeners();                        // Initialize timer hub            setTimeout(() => {                initializeTimerHub();            }, 100);        }        // Haptic feedback function (visual animation removed)        function hapticFeedback(intensity = 'medium') {            if ('vibrate' in navigator) {                const patterns = {                    light: [10],                    medium: [20],                    strong: [50]                };                navigator.vibrate(patterns[intensity] || patterns.medium);            }        }        // Enhanced form validation        function setupFormValidation() {            const descInput = document.getElementById('descInput');            const timeInput = document.getElementById('appointmentTime');                        descInput.addEventListener('input', () => validateField(descInput));            descInput.addEventListener('blur', () => validateField(descInput));            timeInput.addEventListener('input', () => validateField(timeInput));            timeInput.addEventListener('blur', () => validateField(timeInput));        }        function validateField(field) {            const feedbackElement = document.getElementById(field.id.replace('Input', 'Feedback').replace('Time', 'Feedback'));            if (!feedbackElement) return;            let isValid = true;            let message = '';            if (field.id === 'descInput') {                const value = field.value.trim();                if (value.length === 0) {                    isValid = false;                    message = 'Please enter appointment initials';                } else if (value.length !== 2) {                    isValid = false;                    message = 'Please enter exactly 2 letters';                } else if (!/^[A-Za-z]{2}$/.test(value)) {                    isValid = false;                    message = 'Please use only letters';                } else {                    isValid = true;                    message = '? Valid initials';                }            } else if (field.id === 'appointmentTime') {                const value = field.value;                if (!value) {                    isValid = false;                    message = 'Please select an appointment time';                } else {                    const selectedTime = new Date();                    const [hours, minutes] = value.split(':');                    selectedTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);                                        const now = new Date();                    const timeDiff = selectedTime - now;                                        if (timeDiff < 0) {                        // Check if it's for tomorrow                        selectedTime.setDate(selectedTime.getDate() + 1);                        const newTimeDiff = selectedTime - now;                                                if (newTimeDiff > 0) {                            const hours = Math.floor(newTimeDiff / (1000 * 60 * 60));                            const minutes = Math.floor((newTimeDiff % (1000 * 60 * 60)) / (1000 * 60));                            message = `? Appointment at ${formatTime12Hour(selectedTime)} tomorrow (in ${hours}h ${minutes}m)`;                        } else {                            isValid = false;                            message = 'Time has already passed';                        }                    } else {                        const hours = Math.floor(timeDiff / (1000 * 60 * 60));                        const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));                                                if (hours === 0 && minutes < 5) {                            isValid = false;                            message = 'Please select a time at least 5 minutes from now';                        } else {                            message = `? Appointment at ${formatTime12Hour(selectedTime)} (in ${hours}h ${minutes}m)`;                        }                    }                }            }            feedbackElement.textContent = message;            feedbackElement.className = `input-feedback ${isValid ? 'success' : 'error'}`;                        // Update field styling            if (isValid) {                field.classList.remove('error');                field.classList.add('success');            } else {                field.classList.remove('success');                field.classList.add('error');            }            return isValid;        }        // Specific validation functions        function validateDescInput() {            return validateField(document.getElementById('descInput'));        }        function validateTimeInput() {            return validateField(document.getElementById('appointmentTime'));        }        // Enhanced URL parameter handling for shortcuts        function handleURLParameters() {            const urlParams = new URLSearchParams(window.location.search);            if (urlParams.get('type')) {                document.getElementById('tagSelect').value = urlParams.get('type');            }            if (urlParams.get('desc')) {                document.getElementById('descInput').value = urlParams.get('desc').substring(0, 2).toUpperCase();            }        }        // Smart auto-focus (no default time)        function setupSmartDefaults() {            // Auto-focus on first input when page loads            setTimeout(() => {                document.getElementById('tagSelect').focus();            }, 500);        }        // Android time input helper        function setupAndroidTimeHelper() {            const timeInput = document.getElementById('appointmentTime');                        // Add change listener for Android time validation            timeInput.addEventListener('change', function() {                const value = this.value;                if (value) {                    try {                        // Validate time format for Android                        const [hours, minutes] = value.split(':').map(num => parseInt(num, 10));                                                if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {                            showErrorMessage('Please enter a valid time');                            this.value = '';                            return;                        }                                                // Create a test time to ensure it's valid                        const testTime = new Date();                        testTime.setHours(hours, minutes, 0, 0);                                                // Show feedback for users in 12-hour format                        const feedback = document.getElementById('timeFeedback');                        if (feedback) {                            feedback.textContent = `? Time set: ${formatTime12Hour(testTime)}`;                            feedback.className = 'input-feedback success';                        }                                            } catch (error) {                        console.error('Time validation error:', error);                        showErrorMessage('Invalid time format. Please try again.');                        this.value = '';                    }                }            });                        // Add input listener for real-time validation on Android            timeInput.addEventListener('input', function() {                const feedback = document.getElementById('timeFeedback');                if (feedback && this.value) {                    feedback.textContent = 'Validating time...';                    feedback.className = 'input-feedback';                }            });                        // Add focus listener to help Android users            timeInput.addEventListener('focus', function() {                if ('vibrate' in navigator) {                    navigator.vibrate([50]);                }                                // Show help text for users                const feedback = document.getElementById('timeFeedback');                if (feedback && !this.value) {                    feedback.textContent = 'Select appointment time';                    feedback.className = 'input-feedback';                }            });        }        // Enhanced add appointment with better UX        function addAppointment() {            const addButton = document.querySelector('.add-button');            const tag = document.getElementById('tagSelect').value;            const desc = document.getElementById('descInput').value.toUpperCase().trim();            const time = document.getElementById('appointmentTime').value;            // Enhanced button state management            function resetButtonState() {                const button = document.querySelector('.add-button');                if (button) {                    button.classList.remove('loading');                    button.disabled = false;                    button.style.pointerEvents = 'auto';                    button.style.display = 'block';                    button.style.visibility = 'visible';                                        // Ensure button text is correct                    if (editingAppointmentId) {                        button.textContent = 'Update Appointment';                    } else {                        button.textContent = 'Add Appointment';                    }                }            }            // Ensure button exists and is visible            if (!addButton) {                console.error('Add button not found!');                return;            }            // Validate inputs            if (!time) {                showErrorMessage('Please set a valid appointment time.');                document.getElementById('appointmentTime').focus();                hapticFeedback('strong');                resetButtonState();                return;            }            if (desc && desc.length !== 2) {                showErrorMessage('Appointment initials must be exactly 2 letters.');                document.getElementById('descInput').focus();                hapticFeedback('strong');                resetButtonState();                return;            }            if (desc && !/^[A-Za-z]{2}$/.test(desc)) {                showErrorMessage('Appointment initials can only contain letters.');                document.getElementById('descInput').focus();                hapticFeedback('strong');                resetButtonState();                return;            }            // Show loading state            addButton.classList.add('loading');            addButton.disabled = true;            try {                // Haptic feedback for successful action                hapticFeedback('medium');                // Get selected reminder times (multi-select)                const selectedReminders = getSelectedReminderTimes();                if (selectedReminders.length === 0) {                    showErrorMessage('Please select at least one reminder time.');                    resetButtonState();                    return;                }                // Get 3-minute warning preference                const threeMinuteWarning = document.getElementById('threeMinuteWarning').checked;                const now = new Date();                                // Enhanced time parsing for Android compatibility                let appointmentTime;                try {                    // Parse the time input more reliably                    const [hours, minutes] = time.split(':').map(num => parseInt(num, 10));                                        // Create appointment time with explicit hour/minute setting                    appointmentTime = new Date();                    appointmentTime.setHours(hours, minutes, 0, 0);                                        // If the time is in the past today, set it for tomorrow                    if (appointmentTime <= now) {                        appointmentTime.setDate(appointmentTime.getDate() + 1);                    }                } catch (error) {                    console.error('Time parsing error:', error);                    showErrorMessage('Invalid time format. Please select a valid time.');                    resetButtonState();                    return;                }                                // Check if time is too soon                const timeDiff = appointmentTime - now;                if (timeDiff < 5 * 60 * 1000) { // Less than 5 minutes                    showErrorMessage('Please select a time at least 5 minutes from now.');                    resetButtonState();                    return;                }            const totalDuration = appointmentTime - now;            if (editingAppointmentId) {                // Edit existing appointment                const appointmentIndex = appointments.findIndex(app => app.id === editingAppointmentId);                if (appointmentIndex !== -1) {                    clearInterval(countdownIntervals[editingAppointmentId]);                    clearInterval(reminderIntervals[editingAppointmentId]);                    appointments[appointmentIndex] = {                        id: editingAppointmentId,                        tag: tag,                        desc: desc || tag.substring(0, 2).toUpperCase(),                        appointmentTime: appointmentTime,                        reminderTimes: selectedReminders, // Now stores array of reminder times                        threeMinuteWarning: threeMinuteWarning,                        totalDuration: totalDuration                    };                                        // Update in IndexedDB                    updateAppointmentInDB(appointments[appointmentIndex]);                }                editingAppointmentId = null;                addButton.textContent = 'Add Appointment';                showSuccessMessage('Appointment updated successfully!');            } else {                // Add new appointment                const appointment = {                    id: Date.now(),                    tag: tag,                    desc: desc || tag.substring(0, 2).toUpperCase(),                    appointmentTime: appointmentTime,                    reminderTimes: selectedReminders, // Now stores array of reminder times                    threeMinuteWarning: threeMinuteWarning,                    totalDuration: totalDuration                };                                // Save to IndexedDB first, then add to memory array                saveAppointmentToDB(appointment).then((savedId) => {                    if (savedId) {                        appointment.id = savedId;                    }                    appointments.push(appointment);                    appointments.sort((a, b) => a.appointmentTime - b.appointmentTime);                    updateAppointmentList();                    updateWakeLock();                    updatePageTitle();                });                                showSuccessMessage('Appointment saved successfully!');            }                        // Schedule notifications for the new/updated appointment            if (editingAppointmentId) {                const updatedAppointment = appointments.find(app => app.id === editingAppointmentId);                if (updatedAppointment) {                    crossPlatformNotificationManager.scheduleAppointmentNotifications(updatedAppointment);                }            } else {                const newAppointment = appointments[appointments.length - 1];                if (newAppointment) {                    crossPlatformNotificationManager.scheduleAppointmentNotifications(newAppointment);                }            }                        // Clear loading state immediately            resetButtonState();                        // Reset form with enhanced UX            setTimeout(() => {                document.getElementById('descInput').value = '';                document.getElementById('appointmentTime').value = '';                document.getElementById('threeMinuteWarning').checked = false;                document.getElementById('tagSelect').focus();            }, 100);            isDataInput = false; // Reset form state                        } catch (error) {                console.error('Error adding appointment:', error);                showErrorMessage('Failed to add appointment. Please try again.');                resetButtonState();            }        }        function handleServiceWorkerMessage(event) {            const { type, payload } = event.data;                        switch (type) {                case 'SYNC_APPOINTMENTS':                    console.log('Appointments synced:', payload);                    break;                case 'CHECK_APPOINTMENTS':                    console.log('Background appointment check:', payload);                    break;            }        }        // Enhanced message system        function showErrorMessage(message) {            showMessage(message, 'error');        }        function showSuccessMessage(message) {            showMessage(message, 'success');        }        function showMessage(message, type = 'info') {            // Remove any existing messages            const existingMessage = document.querySelector('.app-message');            if (existingMessage) {                existingMessage.remove();            }            const messageEl = document.createElement('div');            messageEl.className = `app-message ${type}`;            messageEl.innerHTML = `                <div class="message-content">                    <span class="message-icon">${type === 'success' ? '?' : type === 'error' ? '?' : '??'}</span>                    <span class="message-text">${message}</span>                    <button class="message-close" onclick="this.parentElement.parentElement.remove()"></button>                </div>            `;                        // Add styles if not already added            if (!document.querySelector('.message-styles')) {                const styles = document.createElement('style');                styles.className = 'message-styles';                styles.textContent = `                    .app-message {                        position: fixed;                        top: 20px;                        left: 50%;                        transform: translateX(-50%);                        z-index: 10000;                        animation: slideDown 0.3s ease-out;                        max-width: 90vw;                        box-shadow: var(--shadow-2xl);                    }                    .app-message.success { background: var(--success-gradient); }                    .app-message.error { background: var(--alarm-gradient); }                    .app-message.info { background: var(--primary-gradient); }                    .message-content {                        display: flex;                        align-items: center;                        gap: 12px;                        padding: 16px 20px;                        border-radius: var(--border-radius);                        color: white;                        font-weight: 600;                        backdrop-filter: blur(10px);                    }                    .message-close {                        background: none;                        border: none;                        color: white;                        font-size: 20px;                        cursor: pointer;                        padding: 0;                        width: 24px;                        height: 24px;                        display: flex;                        align-items: center;                        justify-content: center;                        border-radius: 50%;                        transition: background-color 0.2s ease;                    }                    .message-close:hover {                        background-color: rgba(255, 255, 255, 0.2);                    }                `;                document.head.appendChild(styles);            }            document.body.appendChild(messageEl);            // Auto-remove after 5 seconds            setTimeout(() => {                if (messageEl.parentElement) {                    messageEl.style.animation = 'slideUp 0.3s ease-out forwards';                    setTimeout(() => messageEl.remove(), 300);                }            }, 5000);            return messageEl;        }        function showUpdateAvailable() {            const updateBtn = document.createElement('button');            updateBtn.innerHTML = '?? Update Available - Click to Refresh';            updateBtn.className = 'update-button';            updateBtn.onclick = () => {                window.location.reload();            };                        document.body.insertBefore(updateBtn, document.body.firstChild);                        // Auto-hide after 10 seconds            setTimeout(() => {                if (updateBtn.parentNode) {                    updateBtn.remove();                }            }, 10000);        }        function handleURLParameters() {            const urlParams = new URLSearchParams(window.location.search);            const action = urlParams.get('action');                        if (action === 'add') {                // Focus on the first input field                document.getElementById('tagSelect').focus();            }        }        // Helper function to get responsive countdown label        function getResponsiveCountdownLabel(type, segmentWidth) {            const labels = {                hours: {                    full: 'Hours',                    truncated: 'Hrs',                    short: 'H'                },                minutes: {                    full: 'Minutes',                    truncated: 'Mins',                    short: 'M'                },                seconds: {                    full: 'Seconds',                    truncated: 'Secs',                    short: 'S'                }            };            // Determine label based on available width            if (segmentWidth > 80) {                return labels[type].full;            } else if (segmentWidth > 50) {                return labels[type].truncated;            } else if (segmentWidth > 30) {                return labels[type].short;            } else {                return ''; // No label if too narrow            }        }        // Update countdown segment responsiveness        function updateCountdownResponsiveness(appointmentId) {            const countdownContainer = document.getElementById(`countdown-${appointmentId}`);            if (!countdownContainer) return;            const segments = countdownContainer.querySelectorAll('.countdown-segment');            const containerWidth = countdownContainer.offsetWidth;                        segments.forEach((segment, index) => {                const segmentWidth = segment.offsetWidth;                const label = segment.querySelector('.countdown-label');                                if (!label) return;                // Determine segment width category                let widthCategory = 'normal';                if (segmentWidth < 30) {                    widthCategory = 'tiny';                } else if (segmentWidth < 50) {                    widthCategory = 'very-narrow';                } else if (segmentWidth < 80) {                    widthCategory = 'narrow';                }                segment.setAttribute('data-width', widthCategory);                // Update label text based on type and available space                const segmentType = index === 0 ? 'hours' : index === 1 ? 'minutes' : 'seconds';                const responsiveLabel = getResponsiveCountdownLabel(segmentType, segmentWidth);                                if (responsiveLabel) {                    label.textContent = responsiveLabel;                    label.style.display = 'block';                } else {                    label.style.display = 'none';                }            });        }        // Helper function to scroll to specific appointment        function scrollToAppointment(appointmentId) {            const appointmentElement = document.getElementById(`appointment-${appointmentId}`);            if (appointmentElement) {                appointmentElement.scrollIntoView({                     behavior: 'smooth',                     block: 'center'                 });                                // Add highlight effect                appointmentElement.style.animation = 'highlightPulse 2s ease-in-out';                setTimeout(() => {                    appointmentElement.style.animation = '';                }, 2000);            }        }        // Update wake lock management        function updateWakeLock() {            wakeLockManager.update();        }        // Update current time display        function updateCurrentTime() {            const now = new Date();            document.getElementById('currentTime').textContent = `Current Time: ${formatTime12Hour(now)}`;        }        // Note: Enhanced addAppointment function is already defined above        // Update appointment list display        function updateAppointmentList() {            const list = document.getElementById('appointmentList');                        if (appointments.length === 0) {                list.innerHTML = '';                updateTimerHub(); // Update timer hub when no appointments                return;            }                        list.innerHTML = '<h2>Appointments</h2>';                        appointments.forEach((app) => {                const appointmentElement = document.createElement('div');                appointmentElement.className = 'appointment';                appointmentElement.id = `appointment-${app.id}`;                                // Get the color for this appointment type                const appointmentColor = appointmentColors[app.tag] || '#61dafb';                                // Apply color coding to the appointment border                appointmentElement.style.borderLeft = `4px solid ${appointmentColor}`;                appointmentElement.style.boxShadow = `0 2px 8px rgba(97, 218, 251, 0.08), inset 0 0 0 1px ${appointmentColor}20`;                                appointmentElement.innerHTML = `                    <div class="appointment-info">                        <div class="appointment-details">                            <div class="appointment-title" style="color: ${appointmentColor};">                                <div class="type-indicator" style="background: ${appointmentColor};">${app.desc || app.tag.substring(0, 2).toUpperCase()}</div>                                <span>${app.tag}</span>                                ${app.desc && app.desc !== app.tag.substring(0, 2).toUpperCase() ? `<span style="opacity: 0.8;">(${app.desc})</span>` : ''}                            </div>                            <div class="appointment-timing">                                <div class="timing-row">                                    <span class="timing-label">?? Appointment Time:</span>                                    <span class="timing-value">${formatTime12Hour(app.appointmentTime)}</span>                                </div>                                <div class="timing-row reminder-row ${(app.reminderTimes || []).length > 4 ? 'compact' : ''}">                                    <span class="timing-label">? Reminders:</span>                                    <span class="timing-value">${formatReminderTimes(app.reminderTimes || [{ minutes: 60, label: '1h' }])}</span>                                </div>                                <div class="timing-row">                                    <span class="timing-label">?? 3-min Warning:</span>                                    <span class="timing-value" style="color: ${app.threeMinuteWarning ? '#4ade80' : '#ef4444'};">                                        ${app.threeMinuteWarning ? '? Enabled' : '? Disabled'}                                    </span>                                </div>                                <div class="timing-row">                                    <span class="timing-label">?? Date:</span>                                    <span class="timing-value">${app.appointmentTime.toLocaleDateString()}</span>                                </div>                            </div>                        </div>                        <div class="appointment-buttons">                            <button class="edit-btn" onclick="editAppointment(${app.id})" title="Edit this appointment">                                ?? <span>Edit</span>                            </button>                            <button class="remove-btn" onclick="handleRemoveAppointment(${app.id})" title="Remove this appointment">                                ??? <span>Remove</span>                            </button>                        </div>                    </div>                    <div class="countdown-container" id="countdown-${app.id}">                        <div class="countdown-segment hours" id="hours-${app.id}">                            <div class="countdown-number">0</div>                            <div class="countdown-label">Hours</div>                        </div>                        <div class="countdown-segment minutes" id="minutes-${app.id}">                            <div class="countdown-number">0</div>                            <div class="countdown-label">Minutes</div>                        </div>                        <div class="countdown-segment seconds" id="seconds-${app.id}">                            <div class="countdown-number">0</div>                            <div class="countdown-label">Seconds</div>                        </div>                    </div>                    <div class="reminder-indicator" id="reminder-indicator-${app.id}"></div>                    <div class="countdown-text" id="countdown-text-${app.id}">Loading...</div>                `;                list.appendChild(appointmentElement);                                if (!countdownIntervals[app.id]) {                    startCountdown(app);                }                if (!reminderIntervals[app.id]) {                    setReminder(app);                }            });                        // Update timer hub whenever appointment list changes            updateTimerHub();        }        // Enhanced edit appointment with visual indicators        function editAppointment(id) {            const appointment = appointments.find(app => app.id === id);            if (!appointment) return;                        // Set editing state            editingAppointmentId = id;                        // Add visual indicators            addEditingVisualIndicators(id);                        // Populate form fields            document.getElementById('tagSelect').value = appointment.tag;            document.getElementById('descInput').value = appointment.desc || '';                        // Set appointment time with proper formatting            try {                const timeString = appointment.appointmentTime.toTimeString().slice(0, 5);                document.getElementById('appointmentTime').value = timeString;                                // Show user-friendly feedback                const feedback = document.getElementById('timeFeedback');                if (feedback) {                    feedback.textContent = `? Time set: ${formatTime12Hour(appointment.appointmentTime)}`;                    feedback.className = 'input-feedback success';                }            } catch (error) {                console.error('Error setting time for edit:', error);                showErrorMessage('Error loading appointment time. Please set the time manually.');            }                        // Set reminder times            const reminderTimes = appointment.reminderTimes || [{ minutes: 60, label: '1h' }];            const reminderMinutes = reminderTimes.map(r => r.minutes);            setReminderTimes(reminderMinutes);                        // Set 3-minute warning            document.getElementById('threeMinuteWarning').checked = appointment.threeMinuteWarning || false;                        // Update buttons and form appearance            document.querySelector('.add-button').textContent = '?? Update Appointment';            document.querySelector('.cancel-button').style.display = 'block';            document.querySelector('.form-section').classList.add('editing');                        // Scroll to form            document.querySelector('.form-section').scrollIntoView({                 behavior: 'smooth',                block: 'center'            });                        // Show success message            showSuccessMessage(`Editing appointment: ${appointment.desc || appointment.tag}`);        }        // Add visual editing indicators        function addEditingVisualIndicators(editingId) {            // Remove previous editing indicators            document.querySelectorAll('.appointment').forEach(el => {                el.classList.remove('editing');            });                        // Add editing class to the appointment being edited            const editingAppointment = document.querySelector(`#appointment-${editingId}`);            if (editingAppointment) {                editingAppointment.classList.add('editing');            }        }        // Enhanced cancel edit function        function cancelEdit() {            if (!editingAppointmentId) return;                        // Remove visual indicators            removeEditingVisualIndicators();                        // Reset form            resetFormToDefault();                        // Clear editing state            editingAppointmentId = null;                        // Update buttons            document.querySelector('.add-button').textContent = 'Add Appointment';            document.querySelector('.cancel-button').style.display = 'none';            document.querySelector('.form-section').classList.remove('editing');                        // Show cancellation message            showInfoMessage('Edit cancelled');                        // Haptic feedback            hapticFeedback('light');        }        // Remove visual editing indicators        function removeEditingVisualIndicators() {            document.querySelectorAll('.appointment').forEach(el => {                el.classList.remove('editing');            });            document.querySelector('.form-section').classList.remove('editing');        }        // Reset form to default state        function resetFormToDefault() {            document.getElementById('tagSelect').value = 'General';            document.getElementById('descInput').value = '';            document.getElementById('appointmentTime').value = '';            document.getElementById('threeMinuteWarning').checked = false;                        // Reset to default reminder selection (1 hour)            setReminderTimes([60]);                        // Clear feedback messages            const feedbacks = document.querySelectorAll('.input-feedback');            feedbacks.forEach(feedback => {                feedback.textContent = '';                feedback.className = 'input-feedback';            });        }        // Wrapper function for async removeAppointment        function handleRemoveAppointment(id) {            const appointment = appointments.find(app => app.id === id);            if (!appointment) return;                        if (confirm(`Are you sure you want to remove the ${appointment.tag} appointment?`)) {                removeAppointment(id).then(() => {                    hapticFeedback('strong');                    showSuccessMessage('Appointment removed successfully!');                }).catch(error => {                    console.error('Failed to remove appointment:', error);                    showErrorMessage('Failed to remove appointment. Please try again.');                });            }        }        // Remove appointment        async function removeAppointment(id) {            if (editingAppointmentId === id) {                cancelEdit();            }                        // Clear all notifications for this appointment            crossPlatformNotificationManager.clearAppointmentNotifications(id);                        // Remove from IndexedDB first and wait for completion            await deleteAppointmentFromDB(id);                        appointments = appointments.filter(app => app.id !== id);            clearInterval(countdownIntervals[id]);            delete countdownIntervals[id];            clearInterval(reminderIntervals[id]);            delete reminderIntervals[id];                        updateAppointmentList();            updateWakeLock();            updatePageTitle();            isDataInput = appointments.length > 0;        }        // Start countdown for appointment        function startCountdown(appointment) {            function updateCountdown() {                const now = new Date();                let timeLeft = appointment.appointmentTime - now;                const hoursElement = document.getElementById(`hours-${appointment.id}`);                const minutesElement = document.getElementById(`minutes-${appointment.id}`);                const secondsElement = document.getElementById(`seconds-${appointment.id}`);                const countdownText = document.getElementById(`countdown-text-${appointment.id}`);                const reminderIndicator = document.getElementById(`reminder-indicator-${appointment.id}`);                // Calculate reminder seconds using multiple reminders                const reminderTimes = appointment.reminderTimes || [{ minutes: 60, label: '1h' }];                const earliestReminderMinutes = Math.max(...reminderTimes.map(r => r.minutes));                const reminderSeconds = earliestReminderMinutes * 60;                if (!hoursElement || !minutesElement || !secondsElement || !countdownText || !reminderIndicator) {                    clearInterval(countdownIntervals[appointment.id]);                    delete countdownIntervals[appointment.id];                    return;                }                const totalSeconds = Math.floor(timeLeft / 1000);                const hours = Math.floor(totalSeconds / 3600);                const minutes = Math.floor((totalSeconds % 3600) / 60);                const seconds = totalSeconds % 60;                // Calculate proportional widths for visual bars                const totalDuration = appointment.totalDuration || 24 * 3600 * 1000; // Default to 24 hours                const remainingDuration = Math.max(0, timeLeft);                const progressPercent = Math.max(0, Math.min(100, (remainingDuration / totalDuration) * 100));                // Calculate individual segment widths based on their contribution                const hoursPercent = hours > 0 ? (hours / 24) * 100 : 0;                const minutesPercent = minutes > 0 ? (minutes / 60) * (100 - hoursPercent) / 2 : 0;                const secondsPercent = Math.max(10, 100 - hoursPercent - minutesPercent); // Ensure seconds always visible                // Update segment widths and content                hoursElement.style.flex = `${Math.max(0.1, hoursPercent / 100)}`;                minutesElement.style.flex = `${Math.max(0.3, minutesPercent / 100 + 0.2)}`;                secondsElement.style.flex = `${Math.max(0.3, secondsPercent / 100 + 0.2)}`;                // Enhanced visual countdown segments with responsive labels                setTimeout(() => {                    // Get responsive labels based on current segment width                    const hoursLabel = getResponsiveCountdownLabel('hours', hoursElement.offsetWidth);                    const minutesLabel = getResponsiveCountdownLabel('minutes', minutesElement.offsetWidth);                    const secondsLabel = getResponsiveCountdownLabel('seconds', secondsElement.offsetWidth);                    hoursElement.innerHTML = `                        <div class="countdown-number">${hours}</div>                        <div class="countdown-label">${hoursLabel}</div>                    `;                    minutesElement.innerHTML = `                        <div class="countdown-number">${minutes}</div>                        <div class="countdown-label">${minutesLabel}</div>                    `;                    secondsElement.innerHTML = `                        <div class="countdown-number">${seconds}</div>                        <div class="countdown-label">${secondsLabel}</div>                    `;                    // Update responsiveness for this appointment                    updateCountdownResponsiveness(appointment.id);                }, 10); // Small delay to ensure layout is updated                // Hide segments when they're zero (except seconds)                hoursElement.style.display = hours > 0 ? 'flex' : 'none';                minutesElement.style.display = (minutes > 0 || hours > 0) ? 'flex' : 'none';                // Enhanced countdown text with smart formatting                let displayText;                if (hours > 0) {                    displayText = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;                } else if (minutes > 0) {                    displayText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;                } else {                    displayText = `${seconds}s`;                }                // Enhanced visual states based on time remaining with attention animations                countdownText.className = 'countdown-text';                const appointmentElement = document.getElementById(`appointment-${appointment.id}`);                                // Remove all attention classes first                if (appointmentElement) {                    appointmentElement.classList.remove('in-countdown', 'shake-attention', 'urgent-attention', 'warning-attention');                }                                if (totalSeconds <= 60) {                    countdownText.classList.add('urgent');                    countdownText.textContent = `${displayText}${editingAppointmentId === appointment.id ? ' ??' : ''}`;                    if (appointmentElement) {                        appointmentElement.style.boxShadow = '0 0 20px rgba(239, 83, 80, 0.4)';                        appointmentElement.classList.add('urgent-attention');                    }                } else if (totalSeconds <= 180 && appointment.threeMinuteWarning) { // 3 minutes and warning enabled                    countdownText.classList.add('warning');                    countdownText.textContent = `?? ${displayText} (3-min warning active)${editingAppointmentId === appointment.id ? ' ??' : ''}`;                    if (appointmentElement) {                        appointmentElement.style.boxShadow = '0 0 18px rgba(255, 193, 7, 0.4)';                        appointmentElement.classList.add('warning-attention');                    }                } else if (totalSeconds <= 300) { // 5 minutes                    countdownText.classList.add('warning');                    countdownText.textContent = `${displayText}${editingAppointmentId === appointment.id ? ' ??' : ''}`;                    if (appointmentElement) {                        appointmentElement.style.boxShadow = '0 0 15px rgba(255, 167, 38, 0.3)';                        appointmentElement.classList.add('warning-attention');                    }                } else if (totalSeconds <= reminderSeconds) { // In countdown phase                    countdownText.textContent = `${displayText}${editingAppointmentId === appointment.id ? ' ??' : ''}`;                    if (appointmentElement) {                        appointmentElement.style.boxShadow = '';                        appointmentElement.classList.add('in-countdown');                                                // Add gentle shake every 5 seconds during countdown phase                        if (!appointment.shakeInterval) {                            appointment.shakeInterval = setInterval(() => {                                if (appointmentElement) {                                    appointmentElement.classList.add('shake-attention');                                    setTimeout(() => {                                        if (appointmentElement) {                                            appointmentElement.classList.remove('shake-attention');                                        }                                    }, 600);                                }                            }, 5000);                        }                    }                } else {                    // Default case: show regular countdown text                    countdownText.textContent = `${displayText}${editingAppointmentId === appointment.id ? ' ?? EDITING' : ''}`;                    if (appointmentElement) {                        appointmentElement.style.boxShadow = '';                        // Clear shake interval when not in countdown                        if (appointment.shakeInterval) {                            clearInterval(appointment.shakeInterval);                            appointment.shakeInterval = null;                        }                    }                }                // Enhanced reminder indicator with proper animation                const reminderProgress = Math.max(0, Math.min(100, ((reminderSeconds - totalSeconds) / reminderSeconds) * 100));                                // Update the pseudo-element via CSS custom property                reminderIndicator.style.setProperty('--progress', `${reminderProgress}%`);                                // Apply different colors based on urgency                if (totalSeconds <= 60) {                    reminderIndicator.style.setProperty('--indicator-color', 'var(--alarm-gradient)');                } else if (totalSeconds <= reminderSeconds) {                    reminderIndicator.style.setProperty('--indicator-color', 'var(--warning-gradient)');                } else {                    reminderIndicator.style.setProperty('--indicator-color', 'var(--primary-gradient)');                }                // Trigger reminder                if (!appointment.reminderPassed && totalSeconds <= reminderSeconds) {                    appointment.reminderPassed = true;                    playWarningBeep();                                        // Find which reminder time was triggered                    const triggeredReminder = reminderTimes.find(r => r.minutes === earliestReminderMinutes);                    const reminderLabel = triggeredReminder ? triggeredReminder.label : `${earliestReminderMinutes}m`;                                        showMessage(`? Reminder: ${appointment.tag} appointment in ${reminderLabel}!`, 'info');                                        // Enhanced notification for Android                    if (document.hidden && Notification.permission === 'granted') {                        showNotification(                            `? ${appointment.tag} Reminder`,                             `Your appointment starts in ${reminderLabel}!`,                            { appointmentId: appointment.id }                        );                    }                }                                // Appointment time reached                if (timeLeft <= 0) {                    clearInterval(countdownIntervals[appointment.id]);                    delete countdownIntervals[appointment.id];                                        // Clear shake interval when appointment ends                    if (appointment.shakeInterval) {                        clearInterval(appointment.shakeInterval);                        appointment.shakeInterval = null;                    }                                        // Stop countdown notification and send alarm notification                    crossPlatformNotificationManager.stopCountdownNotification(appointment);                    crossPlatformNotificationManager.sendAlarmNotification(appointment);                                        playAlarmSound();                                        countdownText.textContent = "TIME!";                    countdownText.className = 'countdown-text urgent';                                        // Use responsive labels even for final state                    setTimeout(() => {                        const hoursLabel = getResponsiveCountdownLabel('hours', hoursElement.offsetWidth);                        const minutesLabel = getResponsiveCountdownLabel('minutes', minutesElement.offsetWidth);                        const secondsLabel = getResponsiveCountdownLabel('seconds', secondsElement.offsetWidth);                        hoursElement.innerHTML = `<div class="countdown-number">0</div><div class="countdown-label">${hoursLabel}</div>`;                        minutesElement.innerHTML = `<div class="countdown-number">0</div><div class="countdown-label">${minutesLabel}</div>`;                        secondsElement.innerHTML = `<div class="countdown-number">0</div><div class="countdown-label">${secondsLabel}</div>`;                                                updateCountdownResponsiveness(appointment.id);                    }, 10);                                        if (appointmentElement) {                        appointmentElement.classList.add('past');                        appointmentElement.style.boxShadow = '0 0 25px rgba(239, 83, 80, 0.6)';                    }                                        showMessage(`?? ${appointment.tag} appointment time is NOW!`, 'error');                                        // Enhanced notification for Android (fallback)                    if (document.hidden && Notification.permission === 'granted') {                        showNotification(                            `?? ${appointment.tag} Time!`,                             `Your appointment is starting NOW!`,                            { appointmentId: appointment.id, requireInteraction: true }                        );                    }                                        // Auto-remove past appointments after 5 minutes                    setTimeout(async () => {                        await removeAppointment(appointment.id);                    }, 5 * 60 * 1000);                }                                // Update timer hub with current countdown status - throttled for efficiency                if (!appointment.lastTimerHubUpdate || Date.now() - appointment.lastTimerHubUpdate > 500) {                    appointment.lastTimerHubUpdate = Date.now();                    updateTimerHub();                }            }            updateCountdown();            countdownIntervals[appointment.id] = setInterval(updateCountdown, 1000);        }        // Set reminder for appointment        function setReminder(appointment) {            reminderIntervals[appointment.id] = setInterval(() => {                const now = new Date();                const timeUntilAppointment = appointment.appointmentTime - now;                const minutesUntilAppointment = Math.floor(timeUntilAppointment / (1000 * 60));                                // Check against all reminder times                const reminderTimes = appointment.reminderTimes || [{ minutes: 60, label: '1h' }];                const shouldTrigger = reminderTimes.some(r => minutesUntilAppointment === r.minutes);                                if (shouldTrigger) {                    playWarningBeep();                    clearInterval(reminderIntervals[appointment.id]);                    delete reminderIntervals[appointment.id];                }            }, 60000);        }        // Play warning beep with enhanced PWA support        async function playWarningBeep() {            // Use the audio manager            await audioManager.playWarning();                        // Vibrate on mobile devices            if ('vibrate' in navigator) {                navigator.vibrate([200, 100, 200]);            }                        // Show notification if app is in background - Android optimized            if (document.hidden && Notification.permission === 'granted') {                showNotification(                    '? Appointment Reminder',                     'Your appointment reminder time has been reached!',                    { silent: false, requireInteraction: true }                );            }        }        // Play alarm sound with enhanced PWA support        async function playAlarmSound() {            // Use the audio manager            await audioManager.playAlarm();                        // Stronger vibration for appointment time            if ('vibrate' in navigator) {                navigator.vibrate([500, 200, 500, 200, 500]);            }                        // Show notification if app is in background - Android optimized            if (document.hidden && Notification.permission === 'granted') {                showNotification(                    '?? Appointment Time!',                     'Your appointment time is NOW!',                    { silent: false, requireInteraction: true, renotify: true }                );            }        }        // Enhanced notification function with Android optimizations        async function showNotification(title, body, options = {}) {            // Enhanced Android-compatible notification options            const defaultOptions = {                body: body,                icon: './vta-192.png',                badge: './vta-192.png',                vibrate: [200, 100, 200, 100, 200], // Enhanced vibration pattern                requireInteraction: true,                tag: 'appointment-notification-' + Date.now(), // Unique tag for each notification                renotify: true, // Force notification to show even if tag exists                silent: false, // Ensure sound plays                timestamp: Date.now(),                data: {                    timestamp: Date.now(),                    url: window.location.href,                    appointmentId: options.appointmentId || null                },                actions: [                    {                        action: 'view',                        title: '??? View App',                        icon: './vta-192.png'                    },                    {                        action: 'dismiss',                        title: '?? Dismiss',                        icon: './vta-192.png'                    }                ]            };            // Merge custom options with defaults            const notificationOptions = { ...defaultOptions, ...options };            try {                // Check if we have permission                if (Notification.permission !== 'granted') {                    console.warn('Notification permission not granted');                    return;                }                // Try service worker first for persistent notifications                if (serviceWorkerRegistration && 'showNotification' in serviceWorkerRegistration) {                    console.log('Showing service worker notification:', title);                    await serviceWorkerRegistration.showNotification(title, notificationOptions);                }                 // Fallback to regular notification API                else if ('Notification' in window) {                    console.log('Showing regular notification:', title);                    const notification = new Notification(title, notificationOptions);                                        // Enhanced Android event handling                    notification.onclick = function(event) {                        console.log('Notification clicked');                        event.preventDefault();                        window.focus();                        if (notificationOptions.data.appointmentId) {                            scrollToAppointment(notificationOptions.data.appointmentId);                        }                        notification.close();                    };                                        notification.onerror = function(error) {                        console.error('Notification error:', error);                    };                                        // Auto-close after 10 seconds on Android                    setTimeout(() => {                        if (notification) {                            notification.close();                        }                    }, 10000);                }                                // Additional Android fallback - show in-app alert if notifications fail                else {                    console.warn('No notification API available, showing alert');                    showInAppAlert(title, body);                }                            } catch (error) {                console.error('Failed to show notification:', error);                // Fallback to in-app alert                showInAppAlert(title, body);            }        }        // In-app alert fallback for Android        function showInAppAlert(title, body) {            const alertContainer = document.createElement('div');            alertContainer.className = 'android-alert-container';            alertContainer.innerHTML = `                <div class="android-alert">                    <div class="android-alert-icon">??</div>                    <div class="android-alert-content">                        <div class="android-alert-title">${title}</div>                        <div class="android-alert-body">${body}</div>                    </div>                    <button class="android-alert-close" onclick="this.parentElement.parentElement.remove()"></button>                </div>            `;                        // Add styles for Android alert            if (!document.querySelector('.android-alert-styles')) {                const styles = document.createElement('style');                styles.className = 'android-alert-styles';                styles.textContent = `                    .android-alert-container {                        position: fixed;                        top: 20px;                        left: 50%;                        transform: translateX(-50%);                        z-index: 10000;                        max-width: 90vw;                        animation: slideDown 0.3s ease-out;                    }                    .android-alert {                        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);                        color: white;                        padding: 16px 20px;                        border-radius: 12px;                        box-shadow: 0 8px 32px rgba(0,0,0,0.3);                        display: flex;                        align-items: center;                        gap: 12px;                        min-width: 300px;                        backdrop-filter: blur(10px);                    }                    .android-alert-icon {                        font-size: 24px;                        flex-shrink: 0;                    }                    .android-alert-content {                        flex: 1;                    }                    .android-alert-title {                        font-weight: 700;                        font-size: 16px;                        margin-bottom: 4px;                    }                    .android-alert-body {                        font-size: 14px;                        opacity: 0.9;                    }                    .android-alert-close {                        background: rgba(255,255,255,0.2);                        border: none;                        color: white;                        border-radius: 50%;                        width: 28px;                        height: 28px;                        display: flex;                        align-items: center;                        justify-content: center;                        cursor: pointer;                        font-size: 18px;                        transition: background 0.2s;                    }                    .android-alert-close:hover {                        background: rgba(255,255,255,0.3);                    }                    @keyframes slideDown {                        from { transform: translateX(-50%) translateY(-100%); opacity: 0; }                        to { transform: translateX(-50%) translateY(0); opacity: 1; }                    }                `;                document.head.appendChild(styles);            }                        document.body.appendChild(alertContainer);                        // Auto-remove after 8 seconds            setTimeout(() => {                if (alertContainer.parentElement) {                    alertContainer.style.animation = 'slideUp 0.3s ease-out forwards';                    setTimeout(() => alertContainer.remove(), 300);                }            }, 8000);                        // Vibrate on Android            if ('vibrate' in navigator) {                navigator.vibrate([200, 100, 200, 100, 200]);            }        }        // Update page title with next appointment        function updatePageTitle() {            if (appointments.length === 0) {                document.title = 'Visual Appointment Timer';                return;            }            const now = new Date();            const nextAppointment = appointments.find(app => app.appointmentTime > now);                        if (nextAppointment) {                const timeLeft = nextAppointment.appointmentTime - now;                const hours = Math.floor(timeLeft / (1000 * 60 * 60));                const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));                const appointmentTime12h = formatTime12Hour(nextAppointment.appointmentTime);                document.title = `${hours}h ${minutes}m - ${nextAppointment.tag} at ${appointmentTime12h}`;            }        }        // Update page title every minute        setInterval(updatePageTitle, 60000);        // Cancel edit function        function cancelEdit() {            editingAppointmentId = null;            document.querySelector('.add-button').textContent = 'Add Appointment';                        // Reset form            document.getElementById('descInput').value = '';            document.getElementById('appointmentTime').value = '';            document.getElementById('tagSelect').value = 'General';            document.getElementById('reminder1h').checked = true;            // Focus on first input            setTimeout(() => {                document.getElementById('tagSelect').focus();            }, 100);                        showMessage('Edit cancelled', 'info');        }        // Edit appointment function (enhanced version)        // Modern Timer Hub Management - Optimized        let timerHubExpanded = false;        let timerHubAutoHideTimeout = null;        let timerHubUpdateThrottle = null;        let lastTimerHubState = null;        function toggleTimerHub() {            timerHubExpanded = !timerHubExpanded;            const panel = document.getElementById('timerHubPanel');            const fab = document.getElementById('timerHubFab');                        if (timerHubExpanded) {                panel.classList.add('expanded');                fab.setAttribute('aria-expanded', 'true');                // Auto-hide after 10 seconds if no interaction                timerHubAutoHideTimeout = setTimeout(() => {                    if (timerHubExpanded) {                        toggleTimerHub();                    }                }, 10000);                                // Add haptic feedback                triggerHapticFeedback();            } else {                panel.classList.remove('expanded');                fab.setAttribute('aria-expanded', 'false');                clearTimeout(timerHubAutoHideTimeout);            }        }        function updateTimerHub() {            // Throttle updates to prevent excessive DOM manipulation            if (timerHubUpdateThrottle) {                clearTimeout(timerHubUpdateThrottle);            }                        timerHubUpdateThrottle = setTimeout(() => {                performTimerHubUpdate();            }, 100); // Update at most every 100ms        }        function performTimerHubUpdate() {            const hubList = document.getElementById('timerHubList');            const badge = document.getElementById('timerHubBadge');            const fab = document.getElementById('timerHubFab');                        if (!hubList || !badge || !fab) return;                        // Filter active countdown appointments - Fixed logic            const now = new Date();            const activeTimers = appointments.filter(app => {                const timeUntilAppointment = app.appointmentTime - now;                                // Calculate earliest reminder time from multiple reminders                const reminderTimes = app.reminderTimes || [{ minutes: 60, label: '1h' }];                const earliestReminderMinutes = Math.max(...reminderTimes.map(r => r.minutes));                const reminderTime = new Date(app.appointmentTime.getTime() - (earliestReminderMinutes * 60 * 1000));                const timeUntilReminder = reminderTime - now;                                // Show if:                // 1. Appointment hasn't started yet (timeUntilAppointment > 0)                // AND either:                // 2a. Reminder hasn't triggered yet (timeUntilReminder > 0)                // 2b. OR we're in countdown phase (reminder triggered but appointment hasn't started)                return timeUntilAppointment > 0;            });            // Create state hash to avoid unnecessary updates            const currentState = {                count: activeTimers.length,                hasUrgent: activeTimers.some(app => {                    const timeUntilAppointment = app.appointmentTime - now;                    return timeUntilAppointment <= 5 * 60 * 1000 && timeUntilAppointment > 0;                }),                timers: activeTimers.map(app => {                    const timeUntilAppointment = app.appointmentTime - now;                    const reminderTimes = app.reminderTimes || [{ minutes: 60, label: '1h' }];                    const earliestReminderMinutes = Math.max(...reminderTimes.map(r => r.minutes));                    const reminderTime = new Date(app.appointmentTime.getTime() - (earliestReminderMinutes * 60 * 1000));                    const timeUntilReminder = reminderTime - now;                                        return {                        id: app.id,                        timeLeft: Math.floor(Math.max(timeUntilReminder, timeUntilAppointment) / 1000),                        isInCountdown: timeUntilReminder <= 0 && timeUntilAppointment > 0                    };                })            };            // Only update if state has changed            if (lastTimerHubState && JSON.stringify(currentState) === JSON.stringify(lastTimerHubState)) {                return;            }            lastTimerHubState = currentState;            // Update badge efficiently            requestAnimationFrame(() => {                if (activeTimers.length > 0) {                    badge.textContent = activeTimers.length;                    badge.classList.add('visible');                    fab.classList.add('has-timers');                                        if (currentState.hasUrgent) {                        badge.classList.add('urgent');                    } else {                        badge.classList.remove('urgent');                    }                } else {                    badge.classList.remove('visible', 'urgent');                    fab.classList.remove('has-timers');                }                // Update timer list only if panel is expanded                if (timerHubExpanded) {                    updateTimerHubList(activeTimers);                }            });        }        function updateTimerHubList(activeTimers) {            const hubList = document.getElementById('timerHubList');            if (!hubList) return;            if (activeTimers.length === 0) {                hubList.innerHTML = `                    <div class="timer-hub-empty">                        <div class="timer-hub-empty-icon">?</div>                        <p class="timer-hub-empty-text">No active timers</p>                    </div>                `;                return;            }            // Use DocumentFragment for better performance            const fragment = document.createDocumentFragment();                        activeTimers.forEach(app => {                const now = new Date();                                // Calculate reminder time properly using multiple reminders                const reminderTimes = app.reminderTimes || [{ minutes: 60, label: '1h' }];                const earliestReminderMinutes = Math.max(...reminderTimes.map(r => r.minutes));                const reminderTime = new Date(app.appointmentTime.getTime() - (earliestReminderMinutes * 60 * 1000));                const timeUntilReminder = reminderTime - now;                const timeUntilAppointment = app.appointmentTime - now;                                let timeToShow, status, itemClass;                                // Improved logic for displaying countdown status                if (timeUntilReminder > 0) {                    // Before reminder time                    timeToShow = timeUntilReminder;                    status = 'Until Reminder';                    itemClass = 'countdown';                } else if (timeUntilAppointment > 0) {                    // After reminder, before appointment (countdown phase)                    timeToShow = timeUntilAppointment;                    if (timeUntilAppointment <= 60 * 1000) { // 1 minute                        status = 'Starting NOW!';                        itemClass = 'urgent';                    } else if (timeUntilAppointment <= 5 * 60 * 1000) { // 5 minutes                        status = 'Starting Soon!';                        itemClass = 'urgent';                    } else if (timeUntilAppointment <= 15 * 60 * 1000) { // 15 minutes                        status = 'Starting Soon';                        itemClass = 'warning';                    } else {                        status = 'Countdown';                        itemClass = 'countdown';                    }                } else {                    // Past appointment time (shouldn't happen with our filter, but safety)                    return;                }                                const timeString = formatCountdownTime(timeToShow);                const typeColor = appointmentColors[app.type] || appointmentColors[app.tag] || appointmentColors['General'];                const description = app.desc || app.description || app.tag?.substring(0, 2).toUpperCase() || 'AP';                                const itemElement = document.createElement('div');                itemElement.className = `timer-hub-item ${itemClass}`;                itemElement.setAttribute('tabindex', '0');                itemElement.setAttribute('role', 'button');                itemElement.setAttribute('aria-label', `Go to ${description} appointment`);                                itemElement.innerHTML = `                    <div class="timer-hub-item-indicator" style="color: ${typeColor};"></div>                    <div class="timer-hub-item-content">                        <div class="timer-hub-item-title">                            <span style="background: ${typeColor}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 10px; font-weight: 700;">${description}</span>                            <span style="opacity: 0.7;">${app.type || app.tag}</span>                        </div>                        <div class="timer-hub-item-time">${timeString}</div>                        <div class="timer-hub-item-status">${status}</div>                    </div>                `;                                // Add event listeners efficiently                itemElement.addEventListener('click', () => scrollToAppointment(app.id), { passive: true });                itemElement.addEventListener('keydown', (e) => {                    if (e.key === 'Enter' || e.key === ' ') {                        e.preventDefault();                        scrollToAppointment(app.id);                    }                }, { passive: false });                                fragment.appendChild(itemElement);            });            // Replace content in one operation            hubList.innerHTML = '';            hubList.appendChild(fragment);        }        function scrollToAppointment(appointmentId) {            const appointmentElement = document.getElementById(`appointment-${appointmentId}`) ||                                       document.querySelector(`[data-appointment-id="${appointmentId}"]`);            if (appointmentElement) {                // Close timer hub                if (timerHubExpanded) {                    toggleTimerHub();                }                                // Smooth scroll to appointment                appointmentElement.scrollIntoView({                     behavior: 'smooth',                     block: 'center'                 });                                // Add temporary highlight                appointmentElement.classList.add('shake-attention');                setTimeout(() => {                    appointmentElement.classList.remove('shake-attention');                }, 600);                                // Haptic feedback                triggerHapticFeedback();            }        }        function formatCountdownTime(milliseconds) {            if (milliseconds <= 0) return '00:00:00';                        const totalSeconds = Math.floor(milliseconds / 1000);            const hours = Math.floor(totalSeconds / 3600);            const minutes = Math.floor((totalSeconds % 3600) / 60);            const seconds = totalSeconds % 60;                        if (hours > 0) {                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;            } else {                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;            }        }        // Enhanced haptic feedback        function triggerHapticFeedback(intensity = 'light') {            if ('vibrate' in navigator) {                const patterns = {                    light: [10],                    medium: [20],                    heavy: [30]                };                navigator.vibrate(patterns[intensity] || patterns.light);            }        }        // Auto-hide timer hub when clicking outside - Optimized        let clickOutsideHandler = null;        function setupTimerHubClickOutside() {            if (clickOutsideHandler) {                document.removeEventListener('click', clickOutsideHandler);            }                        clickOutsideHandler = (e) => {                const timerHub = document.getElementById('timerHubContainer');                if (timerHubExpanded && timerHub && !timerHub.contains(e.target)) {                    toggleTimerHub();                }            };                        document.addEventListener('click', clickOutsideHandler, { passive: true });        }        // Optimized initialization        function initializeTimerHub() {            updateTimerHub();            setupTimerHubClickOutside();                        // Setup intersection observer for efficiency when panel is off-screen            if ('IntersectionObserver' in window) {                const timerHubContainer = document.getElementById('timerHubContainer');                if (timerHubContainer) {                    const observer = new IntersectionObserver((entries) => {                        entries.forEach(entry => {                            if (entry.isIntersecting) {                                // Timer hub is visible, enable full updates                                if (timerHubExpanded) {                                    updateTimerHubList(                                        appointments.filter(app => {                                            const now = new Date();                                            const reminderTimes = app.reminderTimes || [{ minutes: 60, label: '1h' }];                                            const earliestReminderMinutes = Math.max(...reminderTimes.map(r => r.minutes));                                            const timeUntilReminder = app.appointmentTime - now - (earliestReminderMinutes * 60 * 1000);                                            const timeUntilAppointment = app.appointmentTime - now;                                            return timeUntilReminder > 0 || (timeUntilAppointment > 0 && timeUntilAppointment <= earliestReminderMinutes * 60 * 1000);                                        })                                    );                                }                            }                        });                    }, { threshold: 0.1 });                                        observer.observe(timerHubContainer);                }            }        }        // Initialize the timer hub on page load        document.addEventListener('DOMContentLoaded', function() {            // Initialize timer hub with delay to ensure DOM is ready            setTimeout(() => {                initializeTimerHub();                                // Add demo state if no appointments exist                if (appointments.length === 0) {                    const badge = document.getElementById('timerHubBadge');                    const fab = document.getElementById('timerHubFab');                    if (badge && fab) {                        // Show a demo state briefly                        badge.textContent = '?';                        badge.classList.add('visible');                        fab.setAttribute('title', 'Timer hub ready - Add appointments to see active timers');                                                // Remove demo state after 3 seconds                        setTimeout(() => {                            if (appointments.length === 0) {                                badge.classList.remove('visible');                                fab.setAttribute('title', 'View active timers');                            }                        }, 3000);                    }                }            }, 100);        });        // Multi-select reminder system functions        function initializeReminderSystem() {            // Setup event listeners for all reminder checkboxes            setupReminderEventListeners();                        // Update the selected count display            updateSelectedCount();        }        function setupReminderEventListeners() {            const reminderCheckboxes = document.querySelectorAll('input[name="reminder"]');            reminderCheckboxes.forEach(checkbox => {                checkbox.addEventListener('change', function() {                    updateSelectedReminderTimes();                    updateSelectedCount();                    hapticFeedback();                });            });        }        function updateSelectedReminderTimes() {            selectedReminderTimes = [];            const reminderCheckboxes = document.querySelectorAll('input[name="reminder"]:checked');            reminderCheckboxes.forEach(checkbox => {                selectedReminderTimes.push({                    minutes: parseInt(checkbox.value),                    label: checkbox.dataset.label || checkbox.nextElementSibling.textContent.replace('?', '').trim()                });            });                        // Sort by time (shortest to longest)            selectedReminderTimes.sort((a, b) => a.minutes - b.minutes);        }        function updateSelectedCount() {            const selectedCount = document.querySelectorAll('input[name="reminder"]:checked').length;            const countElement = document.getElementById('selectedCount');            if (countElement) {                countElement.textContent = `(${selectedCount} selected)`;                countElement.style.color = selectedCount > 0 ? 'var(--primary-color)' : 'rgba(255, 255, 255, 0.6)';            }        }        function getSelectedReminderTimes() {            updateSelectedReminderTimes();            return selectedReminderTimes.length > 0 ? selectedReminderTimes : [{ minutes: 60, label: '1h' }]; // Default to 1 hour if none selected        }        function setReminderTimes(reminderMinutesArray) {            // Uncheck all reminders first            const allCheckboxes = document.querySelectorAll('input[name="reminder"]');            allCheckboxes.forEach(checkbox => checkbox.checked = false);                        // Check the specified reminders            reminderMinutesArray.forEach(minutes => {                const checkbox = document.querySelector(`input[name="reminder"][value="${minutes}"]`);                if (checkbox) {                    checkbox.checked = true;                }            });                        updateSelectedReminderTimes();            updateSelectedCount();                        // Update countdown display if currently editing            updateEditingCountdownDisplay();        }        // Real-time countdown update during editing        function updateEditingCountdownDisplay() {            if (!editingAppointmentId) return;                        const appointment = appointments.find(app => app.id === editingAppointmentId);            if (!appointment) return;                        // Get current form values            const timeInput = document.getElementById('appointmentTime').value;            const threeMinuteWarning = document.getElementById('threeMinuteWarning').checked;            const currentReminderTimes = getSelectedReminderTimes();                        // Update appointment timing display if time has changed            if (timeInput) {                try {                    const [hours, minutes] = timeInput.split(':');                    const newTime = new Date(appointment.appointmentTime);                    newTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);                                        // Update the timing display                    const timingValue = document.querySelector(`#appointment-${editingAppointmentId} .timing-row:first-child .timing-value`);                    if (timingValue) {                        timingValue.textContent = formatTime12Hour(newTime);                        timingValue.style.fontWeight = 'bold';                        timingValue.style.color = '#f59e0b';  // Orange to indicate editing                    }                                        // Update reminders display                    const remindersValue = document.querySelector(`#appointment-${editingAppointmentId} .timing-row:nth-child(2) .timing-value`);                    if (remindersValue) {                        remindersValue.textContent = formatReminderTimes(currentReminderTimes);                        remindersValue.style.fontWeight = 'bold';                        remindersValue.style.color = '#f59e0b';  // Orange to indicate editing                    }                                        // Update 3-minute warning display                    const warningValue = document.querySelector(`#appointment-${editingAppointmentId} .timing-row:nth-child(3) .timing-value`);                    if (warningValue) {                        warningValue.innerHTML = `<span style="color: ${threeMinuteWarning ? '#4ade80' : '#ef4444'}; font-weight: bold;">${threeMinuteWarning ? '? Enabled' : '? Disabled'}</span>`;                    }                                    } catch (error) {                    console.error('Error updating editing display:', error);                }            }        }        // Add event listeners for real-time updates during editing        function setupEditingUpdateListeners() {            // Time input change            const timeInput = document.getElementById('appointmentTime');            if (timeInput) {                timeInput.addEventListener('input', updateEditingCountdownDisplay);                timeInput.addEventListener('change', updateEditingCountdownDisplay);            }                        // 3-minute warning change            const warningCheckbox = document.getElementById('threeMinuteWarning');            if (warningCheckbox) {                warningCheckbox.addEventListener('change', updateEditingCountdownDisplay);            }                        // Reminder checkboxes change            const reminderCheckboxes = document.querySelectorAll('input[name="reminder"]');            reminderCheckboxes.forEach(checkbox => {                checkbox.addEventListener('change', () => {                    updateSelectedReminderTimes();                    updateSelectedCount();                    updateEditingCountdownDisplay();                });            });        }        // Toggle "Please Read" drawer        function togglePleaseRead() {            const content = document.getElementById('pleaseReadContent');            const arrow = document.getElementById('pleaseReadArrow');                        if (content.classList.contains('expanded')) {                content.classList.remove('expanded');                arrow.classList.remove('rotated');            } else {                content.classList.add('expanded');                arrow.classList.add('rotated');            }        }        // Initialize the app when the page loads        document.addEventListener('DOMContentLoaded', initializeApp);